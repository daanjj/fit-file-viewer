<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FIT Viewer: HR, Core Temp, Skin Temp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root{
      --bg:#0f1216;
      --panel:#171b21;
      --text:#e5e9f0;
      --muted:#9aa4b2;
      --accent:#4fc3f7;
      --hr:#e53935;
      --core:#1e88e5;
      --skin:#fb8c00;
      --grid:#232a32;
      --ok:#2e7d32;
      --warn:#ef6c00;
      --err:#e53935;

      --hsi:#ab47bc;
      --dist:#66bb6a;
      --pace:#26c6da;
      --cad:#ffd54f;
      --select:#4fc3f733;
      --select-border:#4fc3f7aa;

      /* HSI zones on white canvas */
      --hsi-bg-green:#2e7d321a;
      --hsi-bg-orange:#ef6c001a;
      --hsi-bg-red:#e539351a;

      /* Elevation background */
      --elev-stroke:#6b728066;
      --elev-fill:#6b728029;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
      font:400 16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Apple Color Emoji,Segoe UI Emoji}
    a{color:var(--accent);text-decoration:none}

    header{
      padding:12px 14px;
      background:var(--panel);
      border-bottom:1px solid #20262e;
    }
    header .title{font-weight:700;font-size:16px;margin-bottom:6px}
    .section-heading{
      font-weight:700;font-size:12px;letter-spacing:.04em;color:var(--muted);
      text-transform:uppercase;margin:6px 0 2px 0;
    }
    .device-line{
      color:var(--text);
      font-size:13px;
      margin:2px 0 8px 0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    input[type="file"]{
      color:var(--text);
      background:#10141a;
      border:1px solid #2a313b;
      padding:8px 10px;border-radius:10px;
      width:100%;
      max-width:420px;
    }
    .btn{
      background:#243041;border:1px solid #334255;color:var(--text);
      padding:8px 12px;border-radius:10px;cursor:pointer;
    }
    .btn:disabled{opacity:0.6;cursor:not-allowed}

    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .chip{
      display:flex;align-items:center;gap:8px;
      background:#11161d;border:1px solid #2a313b;border-radius:999px;padding:6px 10px;cursor:pointer;
      user-select:none;
    }
    .swatch{width:14px;height:14px;border-radius:50%}
    .chip input{display:none}
    .chip input:checked + .label{opacity:1}
    .chip .label{opacity:0.95}
    .chip .unit{color:var(--muted);margin-left:4px}
    .chip .state{color:var(--muted);margin-left:8px;font-weight:600}

    .sticky-bar{
      position:sticky;top:0;z-index:50;
      padding:8px 14px;
      background:var(--panel);
      border-bottom:1px solid #20262e;
      padding-top:calc(8px + env(safe-area-inset-top, 0px));
    }
    .slider-wrap{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .range{
      -webkit-appearance:none;width:min(420px, 100%);height:28px;background:transparent;padding:0;margin:0
    }
    .range:focus{outline:none}
    .range::-webkit-slider-runnable-track{height:6px;background:#2a313b;border-radius:999px;border:0}
    .range::-webkit-slider-thumb{
      -webkit-appearance:none;margin-top:-6px;
      width:18px;height:18px;border-radius:50%;background:#4fc3f7;border:2px solid #1a222b
    }
    .range::-moz-range-track{height:6px;background:#2a313b;border:0;border-radius:999px}
    .range::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:#4fc3f7;border:2px solid #1a222b}

    .stats{display:flex;gap:14px;flex-wrap:wrap;color:var(--muted);font-size:14px;margin-top:6px}
    .kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;
      background:#0f141a;border:1px solid #2a313b;padding:2px 6px;border-radius:6px;color:var(--muted)
    }

    .wrap{padding:10px;display:flex;flex-direction:column;gap:10px}
    .card{background:var(--panel);border:1px solid #20262e;border-radius:12px;padding:10px}
    canvas{
      display:block;width:100%;height:58vh;background:#ffffff;border-radius:10px;
      touch-action:none;
    }
    .msg{font-size:14px;color:var(--muted);margin-top:6px}
    .error{color:var(--err)}
    .ok{color:var(--ok)}
    .warn{color:var(--warn)}
    .footer{color:var(--muted);font-size:12px;text-align:center;padding:16px}

    .modal-backdrop{
      position:fixed;inset:0;background:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center;padding:16px;z-index:100;
    }
    .modal{
      width:100%;max-width:520px;background:var(--panel);border:1px solid #2a313b;border-radius:12px;padding:14px;
      outline:none;
    }
    .modal h3{margin:0 0 8px 0}
    .modal p{color:var(--muted);margin:0 0 12px 0}
    .col{display:flex;flex-direction:column;gap:6px}
    label{font-size:14px;color:var(--muted)}
    select, input[type="number"]{
      background:#0f141a;color:var(--text);border:1px solid #2a313b;border-radius:8px;padding:8px;min-width:140px
    }

    .sel-rect{
      background:var(--select);
      border:1px solid var(--select-border);
    }
  </style>
</head>
<body>
  <header>
    <div class="title">FIT Viewer -- Heart Rate, Core Temp, Skin Temp</div>

    <div class="section-heading" aria-hidden="true">Metadata</div>
    <div id="deviceName" class="device-line" aria-label="Device metadata line"></div>
    <div id="activityTime" class="device-line" aria-label="Activity date and time range"></div>

    <div class="row">
      <input id="file" type="file" accept=".fit" />
      <button id="resetBtn" class="btn" disabled>Reset</button>
      <button id="zoomModeBtn" class="btn" disabled>Zoom: Off</button>
      <button id="zoomClearBtn" class="btn" disabled>Clear Zoom</button>
      <button id="mapBtn" class="btn" disabled>Map Fields</button>
    </div>

    <div class="legend" id="legend">
      <label class="chip"><input type="checkbox" id="toggle-hr" checked><span class="swatch" style="background:var(--hr)"></span><span class="label">Heart Rate <span class="unit">(bpm)</span></span><span class="state" id="state-hr">On</span></label>
      <label class="chip"><input type="checkbox" id="toggle-core" checked><span class="swatch" style="background:var(--core)"></span><span class="label">Core Temp <span class="unit">(°C)</span></span><span class="state" id="state-core">On</span></label>
      <label class="chip"><input type="checkbox" id="toggle-skin" checked><span class="swatch" style="background:var(--skin)"></span><span class="label">Skin Temp <span class="unit">(°C)</span></span><span class="state" id="state-skin">On</span></label>
    </div>
    <div class="legend">
      <label class="chip"><input type="checkbox" id="toggle-hsi"><span class="swatch" style="background:var(--hsi)"></span><span class="label">Heat Strain Index</span><span class="state" id="state-hsi">Off</span></label>
      <label class="chip"><input type="checkbox" id="toggle-dist"><span class="swatch" style="background:var(--dist)"></span><span class="label">Distance <span class="unit">(km)</span></span><span class="state" id="state-dist">Off</span></label>
      <label class="chip"><input type="checkbox" id="toggle-pace"><span class="swatch" style="background:var(--pace)"></span><span class="label">Pace <span class="unit">(min/km)</span></span><span class="state" id="state-pace">Off</span></label>
      <label class="chip"><input type="checkbox" id="toggle-cad"><span class="swatch" style="background:var(--cad)"></span><span class="label">Cadence <span class="unit">(spm)</span></span><span class="state" id="state-cad">Off</span></label>
    </div>
  </header>

  <div class="sticky-bar" aria-label="Controls that stay visible">
    <div class="row slider-wrap">
      <span id="smoothText" class="kbd">Smoothing: 0 s</span>
      <input id="smoothSlider" class="range" type="range" min="0" max="100" step="1" value="75" />
    </div>
    <div class="row" style="margin-top:6px">
      <label class="chip"><input type="checkbox" id="toggle-trim" checked><span class="swatch" style="background:#4b5563"></span><span class="label">Trim Early Noise</span><span class="state" id="state-trim">On</span></label>
      <label class="chip"><input type="checkbox" id="toggle-xaxis"><span class="swatch" style="background:#6366f1"></span><span class="label">Time of Day</span><span class="state" id="state-xaxis">Off</span></label>
    </div>
    <div class="stats" id="stats"></div>
  </div>

  <div class="wrap">
    <div class="card">
      <canvas id="chart" aria-label="Graph; slide to inspect, enable Zoom to select a range"></canvas>
      <div id="message" class="msg">Load a .FIT file. Zoom mode is OFF by default so you can slide across the graph to see values. Turn Zoom mode ON to drag-select a time range. All parsing and rendering happen locally.</div>
    </div>
  </div>

  <div class="footer">
    Privacy: Your file never leaves your device. If temperatures don’t appear automatically, use “Map Fields” to assign developer data fields to Core/Skin and optionally apply a scale (e.g., 0.01).
  </div>

  <div class="modal-backdrop" id="modalBackdrop" role="dialog" aria-modal="true" aria-labelledby="mapTitle">
    <div class="modal" tabindex="-1">
      <h3 id="mapTitle">Map Developer Fields</h3>
      <p>Select which developer fields represent Core and Skin temperatures. Optionally set a scale (e.g., 0.01 if values are in centi-degrees).</p>
      <div class="row">
        <div class="col" style="flex:1 1 220px">
          <label for="coreSelect">Core Temp Field</label>
          <select id="coreSelect"></select>
        </div>
        <div class="col" style="width:120px">
          <label for="coreScale">Core Scale</label>
          <input id="coreScale" type="number" step="0.0001" value="1" />
        </div>
        <div class="col" style="width:120px">
          <label for="coreOffset">Core Offset</label>
          <input id="coreOffset" type="number" step="0.1" value="0" />
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <div class="col" style="flex:1 1 220px">
          <label for="skinSelect">Skin Temp Field</label>
          <select id="skinSelect"></select>
        </div>
        <div class="col" style="width:120px">
          <label for="skinScale">Skin Scale</label>
          <input id="skinScale" type="number" step="0.0001" value="1" />
        </div>
        <div class="col" style="width:120px">
          <label for="skinOffset">Skin Offset</label>
          <input id="skinOffset" type="number" step="0.1" value="0" />
        </div>
      </div>
      <div class="msg" id="mapHint"></div>
      <div class="row" style="justify-content:flex-end;margin-top:12px">
        <button id="cancelMap" class="btn">Cancel</button>
        <button id="applyMap" class="btn">Apply</button>
      </div>
    </div>
  </div>

  <script>
    const textDecoder = new TextDecoder('utf-8');
    const FIT_EPOCH_OFFSET = 631065600; // Seconds from 1970-01-01 to 1989-12-31

    function clamp(v,min,max){return Math.max(min, Math.min(max, v));}
    function pad2(n){return n<10?'0'+n:''+n;}
    function fmtHMS(sec){
      sec = Math.max(0, Math.floor(sec));
      const h = Math.floor(sec/3600);
      const m = Math.floor((sec%3600)/60);
      const s = sec % 60;
      return (h>0? (h+':') : '') + pad2(m) + ':' + pad2(s);
    }
    function fmtTOD(date) {
      if (!(date instanceof Date) || !isFinite(date)) return '--:--:--';
      return pad2(date.getHours()) + ':' + pad2(date.getMinutes()) + ':' + pad2(date.getSeconds());
    }
    function fmtDate(date) {
      if (!(date instanceof Date) || !isFinite(date)) return 'N/A';
      return date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
    }
    function fmtS(sec){
      if (sec >= 10) return Math.round(sec) + ' s';
      if (sec >= 1) return (Math.round(sec*10)/10).toFixed(1) + ' s';
      return (Math.round(sec*100)/100).toFixed(2) + ' s';
    }
    function fmtPace(minPerKm){
      if (!isFinite(minPerKm) || minPerKm<=0) return '--';
      const totalSec = minPerKm*60;
      const m = Math.floor(totalSec/60);
      const s = Math.round(totalSec % 60);
      return `${m}:${pad2(s)} /km`;
    }
    function niceTicks(min, max, count=5){
      if (!isFinite(min) || !isFinite(max)) return [];
      if (min===max) return [min];
      const span = Math.max(1e-12, max - min);
      const step0 = Math.pow(10, Math.floor(Math.log10(span / count)));
      const err = (span / count) / step0;
      let step;
      if (err >= 7.5) step = 10*step0;
      else if (err >= 3.5) step = 5*step0;
      else if (err >= 1.5) step = 2*step0;
      else step = step0;
      const start = Math.ceil(min/step)*step;
      const ticks = [];
      for (let v=start; v<=max+1e-9; v+=step) ticks.push(v);
      if (ticks.length===0) ticks.push(min);
      return ticks;
    }
    function getVar(name, fallback){
      const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      return v || fallback;
    }

    const MANUFACTURERS = {
      1:'Garmin', 13:'SRAM', 15:'Zwift', 23:'Tacx', 32:'Wahoo', 38:'Stages',
      42:'Suunto', 70:'Hammerhead', 76:'Stages', 89:'Polar', 167:'COROS'
    };

    function normalizeProductName(brand, name){
      if (!name) return name;
      const s = String(name).trim();
      const lc = s.toLowerCase();
      const brandLc = (brand||'').toLowerCase();
      if (brandLc === 'garmin') {
        // Forerunner: 'frXX', 'fr XX', 'forerunnerXX', 'forerunner XX' (+ optional 'Music')
        const music = /music/i.test(s);
        const fr = lc.match(/(?:^|\b)(?:fr|forerunner)\s*(\d{2,3})\b/);
        if (fr && fr[1]) return `Forerunner ${fr[1]}${music ? ' Music' : ''}`;
        // Edge: 'edge 530/830/1030, etc'
        const edge = lc.match(/edge\s*(\d{3,4})\b/);
        if (edge && edge[1]) return `Edge ${edge[1]}`;
        // Venu: 'venu', 'venu 2', 'venu sq'
        const venu2 = lc.match(/venu\s*(sq|2|2s|3|3s)?\b/);
        if (venu2) {
          const tag = venu2[1];
          return `Venu${tag ? ' ' + tag.toUpperCase() : ''}`;
        }
        // Vivoactive
        const va = lc.match(/vivoactive\s*(\d+|hr)?\b/);
        if (va) {
          const tag = va[1];
          return `Vivoactive${tag ? ' ' + String(tag).toUpperCase() : ''}`;
        }
        // Instinct: 'instinct', 'instinct 2/2s'
        const inst = lc.match(/instinct\s*(2s|2)?\b/);
        if (inst) return `Instinct${inst[1] ? ' ' + inst[1].toUpperCase() : ''}`;
        // Fenix (normalize diacritics)
        const fenix = lc.match(/f[eē]nix\s*([0-9xXsS+\spro]+)?/);
        if (fenix) {
          const tag = fenix[1] ? fenix[1].replace(/\s+/g,' ').trim() : '';
          return `Fenix${tag ? ' ' + tag.toUpperCase() : ''}`;
        }
        // Epix
        const epix = lc.match(/epix\s*(gen\s*2|pro)?/);
        if (epix) return `Epix${epix[1] ? ' ' + epix[1].replace(/\s+/g,' ').toUpperCase() : ''}`;
        // MARQ
        if (/\bmarq\b/i.test(s)) return 'MARQ';
        // Descent
        const descent = lc.match(/descent\s*([a-z0-9]+)?/);
        if (descent) return `Descent${descent[1] ? ' ' + descent[1].toUpperCase() : ''}`;
        // D2 (Aviation)
        const d2 = lc.match(/\bd2\s*([a-z0-9]+)?/);
        if (d2) return `D2${d2[1] ? ' ' + d2[1].toUpperCase() : ''}`;
      }
      return s;
    }

    class FitParser {
      constructor() {
        this._devKeysUsed = new Set();
        this.devFieldDescriptions = new Map();
        this.fieldDescObjs = [];
        this.fileIds = [];
        this.deviceInfos = [];
        this.fileCreators = [];
      }

      parse(arrayBuffer) {
        const view = new DataView(arrayBuffer);
        let pos = 0;

        const headerSize = view.getUint8(pos); pos+=1;
        pos+=1; pos+=2;
        const dataSize = view.getUint32(pos, true); pos+=4;
        const sig = String.fromCharCode(view.getUint8(pos), view.getUint8(pos+1), view.getUint8(pos+2), view.getUint8(pos+3));
        pos+=4;
        if (headerSize === 14) pos += 2;
        if (sig !== '.FIT') throw new Error('Invalid FIT signature');

        const dataEnd = headerSize + dataSize;
        pos = headerSize;

        const defMap = new Map();
        let lastTimestamp;
        const records = [];

        while (pos < dataEnd) {
          const header = view.getUint8(pos); pos += 1;

          if (header & 0x80) {
            const localNum = (header >> 5) & 0x03;
            const timeOffset = header & 0x1F;
            const def = defMap.get(localNum);
            if (!def) throw new Error('Compressed header refers to unknown local message: ' + localNum);

            let ts;
            if (lastTimestamp === undefined) ts = 0;
            else {
              ts = (lastTimestamp & ~31) + timeOffset;
              if (ts <= lastTimestamp) ts += 32;
            }
            lastTimestamp = ts;

            const {obj, bytesConsumed} = this._decodeData(view, pos, def, true, ts);
            pos += bytesConsumed;
            this._route(def.globalMsgNum, obj, records);
          } else {
            const isDefinition = (header & 0x40) !== 0;
            const hasDeveloper = (header & 0x20) !== 0;
            const localNum = header & 0x0F;

            if (isDefinition) {
              const reserved = view.getUint8(pos); pos+=1;
              const arch = view.getUint8(pos); pos+=1;
              const little = arch === 0;
              const globalMsgNum = view.getUint16(pos, little); pos+=2;

              const numFields = view.getUint8(pos); pos+=1;
              const fields = [];
              for (let i=0;i<numFields;i++) {
                const fieldNum = view.getUint8(pos); pos+=1;
                const size = view.getUint8(pos); pos+=1;
                const baseType = view.getUint8(pos); pos+=1;
                fields.push({num: fieldNum, size, baseTypeId: (baseType & 0x1F)});
              }

              const devFields = [];
              if (hasDeveloper) {
                const numDevFields = view.getUint8(pos); pos+=1;
                for (let i=0;i<numDevFields;i++) {
                  const dfNum = view.getUint8(pos); pos+=1;
                  const dfSize = view.getUint8(pos); pos+=1;
                  const dfIndex = view.getUint8(pos); pos+=1;
                  devFields.push({num: dfNum, size: dfSize, devIndex: dfIndex});
                }
              }

              defMap.set(localNum, {globalMsgNum, little, fields, devFields});
            } else {
              const def = defMap.get(localNum);
              if (!def) throw new Error('Data message refers to unknown local message: ' + localNum);

              const {obj, bytesConsumed} = this._decodeData(view, pos, def, false, undefined);
              pos += bytesConsumed;

              if (def.globalMsgNum === 20) {
                if (obj.timestamp !== undefined) lastTimestamp = obj.timestamp;
                else if (lastTimestamp !== undefined) obj.timestamp = lastTimestamp;
              }
              this._route(def.globalMsgNum, obj, records);
            }
          }
        }

        this._mapFieldDescriptions();

        return {
          records,
          devFieldDescriptions: this.devFieldDescriptions,
          fileIds: this.fileIds,
          deviceInfos: this.deviceInfos,
          fileCreators: this.fileCreators
        };
      }

      _route(globalMsgNum, obj, records){
        if (globalMsgNum === 20) records.push(obj);
        else if (globalMsgNum === 206) this.fieldDescObjs.push(obj);
        else if (globalMsgNum === 0) this.fileIds.push(obj);
        else if (globalMsgNum === 23) this.deviceInfos.push(obj);
        else if (globalMsgNum === 49) this.fileCreators.push(obj);
      }

      _decodeData(view, offset, def, isCompressed, compressedTs) {
        let pos = offset;
        const obj = { timestamp: undefined, fields: {}, dev: {}, _def: def };
        for (const fld of def.fields) {
          const baseId = fld.baseTypeId;
          const size = fld.size;
          if (isCompressed && fld.num === 253) { obj.timestamp = compressedTs; continue; }
          const value = this._readValue(view, pos, baseId, size, def.little);
          pos += size;
          if (fld.num === 253) { if (typeof value === 'number') obj.timestamp = value; }
          else obj.fields[fld.num] = value;
        }
        if (def.devFields && def.devFields.length) {
          for (const df of def.devFields) {
            const key = df.devIndex + ':' + df.num;
            const value = this._readDevValue(view, pos, df.size, def.little);
            pos += df.size;
            obj.dev[key] = value;
            this._devKeysUsed.add(key);
          }
        }
        return { obj, bytesConsumed: pos - offset };
      }

      _readValue(view, pos, baseId, size, little) {
        switch (baseId) {
          case 7: { const bytes = new Uint8Array(view.buffer, view.byteOffset + pos, size); let zero = bytes.indexOf(0); if (zero < 0) zero = bytes.length; return textDecoder.decode(bytes.subarray(0, zero)); }
          case 0: case 2: case 10: return view.getUint8(pos);
          case 1: return view.getInt8(pos);
          case 3: return view.getInt16(pos, little);
          case 4: case 11: return view.getUint16(pos, little);
          case 5: return view.getInt32(pos, little);
          case 6: case 12: return view.getUint32(pos, little);
          case 8: return view.getFloat32(pos, little);
          case 9: return view.getFloat64(pos, little);
          case 13: return view.getUint8(pos);
          case 14: { if (view.getBigInt64) return Number(view.getBigInt64(pos, little)); const lo = view.getUint32(pos, little), hi = view.getInt32(pos+4, little); return hi * 4294967296 + lo; }
          case 15: case 16: { if (view.getBigUint64) return Number(view.getBigUint64(pos, little)); const lo = view.getUint32(pos, little), hi = view.getUint32(pos+4, little); return hi * 4294967296 + lo; }
          default: return view.getUint8(pos);
        }
      }

      _readDevValue(view, pos, size, little) {
        if (size === 4) { const f = view.getFloat32(pos, little); if (Number.isFinite(f) && Math.abs(f) < 1e12) return f; return view.getInt32(pos, little); }
        else if (size === 2) return view.getInt16(pos, little);
        else if (size === 1) return view.getUint8(pos);
        else if (size === 8) { const d = view.getFloat64(pos, little); if (Number.isFinite(d)) return d; if (view.getBigInt64) return Number(view.getBigInt64(pos, little)); const lo = view.getUint32(pos, little), hi = view.getUint32(pos+4, little); return hi * 4294967296 + lo; }
        else return view.getUint8(pos);
      }

      _mapFieldDescriptions() {
        const candidates = Array.from(this._devKeysUsed);
        if (candidates.length === 0) return;
        const set = new Set(candidates);
        for (const obj of this.fieldDescObjs) {
          const nums1b=[], strings=[];
          for (const v of Object.values(obj.fields)) {
            if (typeof v === 'number' && Number.isInteger(v) && v>=0 && v<=255) nums1b.push(v);
            else if (typeof v === 'string' && v.length) strings.push(v.trim());
          }
          let matchedKey=null;
          for (let i=0;i<nums1b.length;i++){
            for (let j=0;j<nums1b.length;j++){
              if (i===j) continue;
              const key = nums1b[i]+':'+nums1b[j];
              if (set.has(key)){ matchedKey=key; break; }
            }
            if (matchedKey) break;
          }
          if (matchedKey){
            let name='', units='';
            if (strings.length===1){ const s=strings[0]; if (/^([cC]|degC|°C|Celsius|K|F|bpm|min\/km|km|m\/s|spm)$/i.test(s)) units=s; else name=s; }
            else if (strings.length>=2){ strings.sort((a,b)=>a.length-b.length); units=strings[0]; name=strings[strings.length-1]; }
            const ex=this.devFieldDescriptions.get(matchedKey)||{};
            if (name) ex.name=name;
            if (units) ex.units=units;
            // Capture scale/offset when provided (per FIT field_description: scale=6, offset=7)
            const sc = obj.fields && typeof obj.fields[6] === 'number' ? obj.fields[6] : undefined;
            const off = obj.fields && typeof obj.fields[7] === 'number' ? obj.fields[7] : undefined;
            if (Number.isFinite(sc) && sc !== 0) ex.scale = sc;
            if (Number.isFinite(off)) ex.offset = off;
            this.devFieldDescriptions.set(matchedKey, ex);
          }
        }
      }
    }

    class LineChart {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.series = [];
        this.dpr = Math.max(1, window.devicePixelRatio || 1);
        this.margins = {top:10, right:60, bottom:26, left:50};
        this.tooltip = {active:false, x:0, nearest:[]};

        this.zoomMode = false;
        this.dragging = false;
        this.selStartPx = 0;
        this.selEndPx = 0;
        this.crosshairDragging = false;
        this.onSelectRange = null;

        this.xRange = [0, 1];
        this.yLeft = [20, 40];
        this.yRight = [50, 180];

        this.elevSeries = [];
        this.hsiBgSeries = [];

        this.baseTime = 0;
        this.xAxisMode = 'delta'; // 'delta' or 'timeOfDay'

        this._bind();
        this.resize();
      }
      setZoomMode(on){ this.zoomMode = !!on; }
      _ensureRanges(){
        const ok = a => Array.isArray(a) && a.length===2 && isFinite(a[0]) && isFinite(a[1]) && a[1]>a[0];
        if (!ok(this.xRange)) this.xRange=[0,1];
        if (!ok(this.yLeft)) this.yLeft=[20,40];
        if (!ok(this.yRight)) this.yRight=[50,180];
      }
      setSeries(series, elevSeries = null){
        this.series = series || [];
        if (Array.isArray(elevSeries)) this.elevSeries = elevSeries;
        this._computeRanges();
        this.draw();
      }
      resize(){
        const rect = this.canvas.getBoundingClientRect();
        const cssW = Math.max(1, rect.width);
        const cssH = Math.max(1, rect.height);
        this.canvas.width = Math.max(1, Math.floor(cssW * this.dpr));
        this.canvas.height = Math.max(1, Math.floor(cssH * this.dpr));
        this.ctx.setTransform(this.dpr,0,0,this.dpr,0,0);
        this.draw();
      }
      _bind(){
        window.addEventListener('resize', () => this.resize(), {passive:true});

        this.canvas.addEventListener('pointerdown', (e)=>{
          const x = this._clientToCanvasX(e.clientX);
          if (this.zoomMode) {
            e.preventDefault();
            this.dragging = true;
            this.selStartPx = x;
            this.selEndPx = x;
            this.tooltip.active = false;
            this.canvas.setPointerCapture(e.pointerId);
            this.draw();
          } else {
            e.preventDefault();
            this.crosshairDragging = true;
            this.tooltip.active = true;
            this.tooltip.x = x;
            this._updateTooltipNearest();
            this.canvas.setPointerCapture(e.pointerId);
            this.draw();
          }
        }, {passive:false});

        this.canvas.addEventListener('pointermove', (e)=>{
          const x = this._clientToCanvasX(e.clientX);
          if (this.dragging) {
            e.preventDefault();
            this.selEndPx = x;
            this.draw();
          } else if (this.crosshairDragging || e.pointerType === 'mouse') {
            e.preventDefault();
            this.tooltip.active = true;
            this.tooltip.x = x;
            this._updateTooltipNearest();
            this.draw();
          }
        }, {passive:false});

        const endDrag = (e)=>{
          if (this.dragging) {
            e.preventDefault();
            this.dragging = false;
            const w = Math.abs(this.selEndPx - this.selStartPx);
            if (w > 6) {
              const x1 = this._pixToDataX(Math.min(this.selStartPx, this.selEndPx));
              const x2 = this._pixToDataX(Math.max(this.selStartPx, this.selEndPx));
              if (this.onSelectRange) this.onSelectRange([x1, x2]);
            }
          }
          if (this.crosshairDragging) {
            e.preventDefault();
            this.crosshairDragging = false;
          }
          try { this.canvas.releasePointerCapture(e.pointerId); } catch {}
        };
        this.canvas.addEventListener('pointerup', endDrag, {passive:false});
        this.canvas.addEventListener('pointercancel', endDrag, {passive:false});
        this.canvas.addEventListener('pointerleave', (e)=>{
          if (this.dragging || this.crosshairDragging) endDrag(e);
          else { this.tooltip.active=false; this.draw(); }
        }, {passive:false});
      }
      _clientToCanvasX(clientX){
        const rect = this.canvas.getBoundingClientRect();
        return (clientX - rect.left);
      }
      _plotWidth(){
        const W = this.canvas.clientWidth || (this.canvas.width/this.dpr);
        return Math.max(1, (W - this.margins.left - this.margins.right));
      }
      _pixToDataX(px){
        const [xMin,xMax]=this.xRange;
        const plotW = this._plotWidth();
        const rel = clamp((px - this.margins.left)/plotW, 0, 1);
        return xMin + rel * (xMax - xMin);
      }
      _computeRanges(){
        let xMin=Infinity, xMax=-Infinity;
        for (const s of this.series) if (s && s.visible && s.points && s.points.length) {
          xMin = Math.min(xMin, s.points[0].x);
          xMax = Math.max(xMax, s.points[s.points.length-1].x);
        }
        if (this.elevSeries && this.elevSeries.length){
          xMin = Math.min(xMin, this.elevSeries[0].x);
          xMax = Math.max(xMax, this.elevSeries[this.elevSeries.length-1].x);
        }
        if (!isFinite(xMin) || !isFinite(xMax) || xMin===xMax) { xMin=0; xMax=1; }
        this.xRange = [xMin, xMax];

        let lmin=Infinity, lmax=-Infinity;
        for (const s of this.series) if (s && s.visible && s.axis==='left' && s.points && s.points.length){
          for (const p of s.points){ if (Number.isFinite(p.y)) { lmin=Math.min(lmin,p.y); lmax=Math.max(lmax,p.y); } }
        }
        if (!isFinite(lmin) || !isFinite(lmax)) { lmin=20; lmax=40; }
        const lstart = Math.floor(lmin);
        let lend = lmax;
        if (lend <= lstart) lend = lstart + 1;
        const spanL = Math.max(1e-6, lend - lstart);
        lend = lend + spanL*0.05;
        this.yLeft = [lstart, lend];

        let rmin=Infinity, rmax=-Infinity;
        for (const s of this.series) if (s && s.visible && s.axis==='right' && s.points && s.points.length){
          for (const p of s.points){ if (Number.isFinite(p.y)) { rmin=Math.min(rmin,p.y); rmax=Math.max(rmax,p.y); } }
        }
        if (!isFinite(rmin) || !isFinite(rmax) || rmin===rmax) { rmin=50; rmax=180; }
        const spanR = Math.max(1e-6, rmax - rmin);
        const padR = spanR*0.08;
        this.yRight = [rmin - padR, rmax + padR];
      }
      _sx(x){
        const [xMin,xMax]=this.xRange;
        const W = this.canvas.clientWidth || (this.canvas.width/this.dpr);
        return this.margins.left + ( (x - xMin) / Math.max(1e-9, (xMax-xMin)) ) * (W - this.margins.left - this.margins.right);
      }
      _syLeft(y){
        const [min,max]=this.yLeft;
        const H = this.canvas.clientHeight || (this.canvas.height/this.dpr);
        return (H - this.margins.bottom) - ( (y - min) / Math.max(1e-9, (max-min)) ) * (H - this.margins.top - this.margins.bottom);
      }
      _syRight(y){
        const [min,max]=this.yRight;
        const H = this.canvas.clientHeight || (this.canvas.height/this.dpr);
        return (H - this.margins.bottom) - ( (y - min) / Math.max(1e-9, (max-min)) ) * (H - this.margins.top - this.margins.bottom);
      }

      _drawElevationBackground(){
        if (!this.elevSeries || this.elevSeries.length < 2) return;

        const [xMin, xMax] = this.xRange;
        let emin = Infinity, emax = -Infinity;
        for (const p of this.elevSeries){
          if (p.x < xMin || p.x > xMax) continue;
          if (Number.isFinite(p.y)) { emin = Math.min(emin, p.y); emax = Math.max(emax, p.y); }
        }
        if (!isFinite(emin) || !isFinite(emax) || emax - emin <= 1e-9) return;

        const ctx = this.ctx;
        const H = this.canvas.clientHeight || (this.canvas.height/this.dpr);
        const plotTop = this.margins.top;
        const plotBottom = H - this.margins.bottom;

        const elevToY = (val)=>{
          const t = (val - emin) / (emax - emin);
          return plotBottom - t * (plotBottom - plotTop);
        };

        ctx.save();
        ctx.beginPath();
        let started = false;
        let firstX = null;
        let lastX = null;
        for (let i=0;i<this.elevSeries.length;i++){
          const p = this.elevSeries[i];
          if (p.x < xMin || p.x > xMax || !Number.isFinite(p.y)) continue;
          const x = this._sx(p.x);
          const y = elevToY(p.y);
          if (!started){ ctx.moveTo(x, y); started = true; firstX = x; }
          else ctx.lineTo(x, y);
          lastX = x;
        }
        if (started){
          ctx.lineTo(lastX, plotBottom);
          ctx.lineTo(firstX, plotBottom);
          ctx.closePath();
          ctx.fillStyle = getVar('--elev-fill', '#6b728029');
          ctx.fill();

          ctx.beginPath();
          started = false;
          const step = Math.max(1, Math.floor(this.elevSeries.length / 3000));
          for (let i=0;i<this.elevSeries.length;i+=step){
            const p = this.elevSeries[i];
            if (p.x < xMin || p.x > xMax || !Number.isFinite(p.y)) continue;
            const x = this._sx(p.x);
            const y = elevToY(p.y);
            if (!started){ ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
          }
          ctx.strokeStyle = getVar('--elev-stroke', '#6b728066');
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        ctx.restore();
      }

      _drawHSIBackground(){
        const hsiSeries = (this.series.find(s => s.id==='hsi') || {}).points || [];
        if (!hsiSeries.length) return;

        const [xMin, xMax] = this.xRange;
        const ctx = this.ctx;
        const W = this.canvas.clientWidth || (this.canvas.width/this.dpr);
        const H = this.canvas.clientHeight || (this.canvas.height/this.dpr);
        const plotLeft = this.margins.left;
        const plotRight = W - this.margins.right;
        const plotTop = this.margins.top;
        const plotBottom = H - this.margins.bottom;

        const zoneOf = (v)=> {
          const c = clamp(v, 0, 5);
          if (!Number.isFinite(c)) return null;
          if (c <= 0.1) return null; // keep background white when HSI <= 0.1
          if (c < 1) return 'green';
          if (c < 2) return 'orange';
          return 'red';
        };
        const colorOf = (zone)=>{
          if (zone==='green') return getVar('--hsi-bg-green', '#2e7d321a');
          if (zone==='orange') return getVar('--hsi-bg-orange', '#ef6c001a');
          if (zone==='red') return getVar('--hsi-bg-red', '#e539351a');
          return null;
        };

        let segments = [];
        for (let i=0;i<hsiSeries.length-1;i++){
          const p1 = hsiSeries[i], p2 = hsiSeries[i+1];
          if (p2.x <= xMin || p1.x >= xMax) continue;
          const x1 = Math.max(xMin, p1.x);
          const x2 = Math.min(xMax, p2.x);
          if (x2 <= x1) continue;
          const z = zoneOf(p1.y);
          if (!z) continue;
          segments.push({x1, x2, zone:z});
        }
        if (!segments.length) return;

        const merged = [];
        let cur = null;
        for (const s of segments){
          if (!cur) cur = {...s};
          else if (s.zone===cur.zone && Math.abs(s.x1 - cur.x2) < 1e-6) {
            cur.x2 = s.x2;
          } else {
            merged.push(cur);
            cur = {...s};
          }
        }
        if (cur) merged.push(cur);

        ctx.save();
        ctx.beginPath();
        ctx.rect(plotLeft, plotTop, plotRight - plotLeft, plotBottom - plotTop);
        ctx.clip();

        for (const s of merged){
          const x1 = this._sx(s.x1);
          const x2 = this._sx(s.x2);
          const c = colorOf(s.zone);
          if (!c) continue;
          ctx.fillStyle = c;
          ctx.fillRect(x1, plotTop, Math.max(0, x2 - x1), plotBottom - plotTop);
        }
        ctx.restore();
      }

      draw(){
        this._ensureRanges();

        const ctx = this.ctx;
        const W = this.canvas.clientWidth || (this.canvas.width/this.dpr);
        const H = this.canvas.clientHeight || (this.canvas.height/this.dpr);

        ctx.save();
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        ctx.setTransform(this.dpr,0,0,this.dpr,0,0);

        // Compute ticks once
        const [xMin,xMax] = this.xRange;
        const xTicks = niceTicks(xMin, xMax, 6);
        const lTicks = niceTicks(this.yLeft[0], this.yLeft[1], 5);
        const rTicks = niceTicks(this.yRight[0], this.yRight[1], 5);

        // Clip and draw backgrounds + series
        ctx.save();
        ctx.beginPath();
        ctx.rect(this.margins.left, this.margins.top, W - this.margins.left - this.margins.right, H - this.margins.top - this.margins.bottom);
        ctx.clip();

        // Backgrounds
        this._drawHSIBackground();
        this._drawElevationBackground();

        // Series lines
        for (const s of this.series) {
          if (!s || !s.visible || !s.points || s.points.length===0) continue;
          ctx.strokeStyle = s.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          let first = true;
          const sy = (s.axis==='left') ? (y)=>this._syLeft(y) : (y)=>this._syRight(y);
          const maxPts = 5000;
          const step = Math.max(1, Math.floor(s.points.length / maxPts));
          for (let i=0;i<s.points.length;i+=step) {
            const p = s.points[i];
            if (!Number.isFinite(p.y)) continue;
            const x = this._sx(p.x);
            const y = sy(p.y);
            if (first) { ctx.moveTo(x,y); first=false; } else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }

        // Selection rectangle
        if (this.dragging) {
          const x1 = this.selStartPx, x2 = this.selEndPx;
          const left = Math.min(x1,x2), right = Math.max(x1,x2);
          const top = this.margins.top, bottom = H - this.margins.bottom;
          ctx.fillStyle = getVar('--select','#4fc3f733');
          ctx.strokeStyle = getVar('--select-border','#4fc3f7aa');
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.rect(left, top, right-left, bottom-top); ctx.fill(); ctx.stroke();
        }

        // Tooltip/crosshair
        if (this.tooltip.active && !this.dragging) {
          const xPix = this.tooltip.x;
          ctx.strokeStyle = '#00000033';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(xPix, this.margins.top);
          ctx.lineTo(xPix, H - this.margins.bottom);
          ctx.stroke();

          const info = this.tooltip.nearest || [];
          if (info.length) {
            const pad = 6;
            const lines = [];
            let tStr = '';
            for (const item of info) if (item.id === 'time') tStr = item.text;
            if (tStr) lines.push(tStr);
            for (const item of info) if (item.id!=='time') lines.push(item.text);
            ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial';
            const widths = lines.map(s=>ctx.measureText(s).width);
            const bw = (widths.length ? Math.max(...widths) : 0) + pad*2;
            const bh = lines.length*16 + pad*2;
            let bx = xPix + 8, by = this.margins.top + 8;
            const Wc = this.canvas.clientWidth || (this.canvas.width/this.dpr);
            if (bx + bw > Wc - 4) bx = xPix - 8 - bw;
            if (bx < 4) bx = 4;
            ctx.fillStyle = '#ffffffee';
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.rect(bx, by, bw, bh); ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#111827';
            for (let i=0;i<lines.length;i++){
              ctx.fillText(lines[i], bx+pad, by+pad+ (i*16));
            }
          }
        }

        ctx.restore(); // end clip

        // Grid lines
        ctx.strokeStyle = getVar('--grid','#2a2f37');
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (const tv of xTicks) {
          const x = this._sx(tv);
          ctx.moveTo(x, this.margins.top);
          ctx.lineTo(x, H - this.margins.bottom);
        }
        ctx.stroke();

        ctx.beginPath();
        for (const yv of lTicks) {
          const y = this._syLeft(yv);
          ctx.moveTo(this.margins.left, y);
          ctx.lineTo(W - this.margins.right, y);
        }
        ctx.stroke();

        // Axis labels
        ctx.fillStyle = '#475569';
        ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (const tv of xTicks) {
          const x = this._sx(tv);
          let labelText;
          if (this.xAxisMode === 'timeOfDay' && this.baseTime > 0) {
            const d = new Date((this.baseTime + tv + FIT_EPOCH_OFFSET) * 1000);
            labelText = fmtTOD(d);
          } else {
            labelText = fmtHMS(tv);
          }
          ctx.fillText(labelText, x, H - this.margins.bottom + 6);
        }

        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (const yv of lTicks) {
          const y = this._syLeft(yv);
          ctx.fillText((Math.round(yv*10)/10).toFixed(1), this.margins.left - 6, y);
        }

        ctx.textAlign = 'left';
        for (const yv of rTicks) {
          const y = this._syRight(yv);
          ctx.fillText((Math.round(yv*10)/10).toFixed(1), W - this.margins.right + 6, y);
        }

        ctx.restore();
      }
      _updateTooltipNearest(){
        const [xMin,xMax] = this.xRange;
        const plotW = this._plotWidth();
        const x = xMin + ( (this.tooltip.x - this.margins.left) / plotW ) * (xMax - xMin);
        const nearest = [];
        let timeText;
        if (this.xAxisMode === 'timeOfDay' && this.baseTime > 0) {
          const d = new Date((this.baseTime + x + FIT_EPOCH_OFFSET) * 1000);
          timeText = 't = ' + fmtTOD(d);
        } else {
          timeText = 't = ' + fmtHMS(clamp(x, xMin, xMax));
        }
        nearest.push({id:'time', text: timeText});

        for (const s of this.series) {
          if (!s || !s.visible || !s.points || !s.points.length===0) continue;
          const idx = this._bisectX(s.points, x);
          let best = null;
          for (const j of [idx-1, idx, idx+1]) {
            if (j>=0 && j < s.points.length) {
              const p = s.points[j];
              const dx = Math.abs(p.x - x);
              if (!best || dx < best.dx) best = {p, dx};
            }
          }
          if (best) {
            const val = best.p.y;
            const vtxt = s.fmt ? s.fmt(val) : String(val);
            nearest.push({id:s.id, text:`${s.name}: ${vtxt}`});
          }
        }
        this.tooltip.nearest = nearest;
      }
      _bisectX(arr, x){
        let lo=0, hi=arr.length-1;
        while (lo<=hi){
          const mid = (lo+hi)>>1;
          if (arr[mid].x < x) lo = mid+1;
          else hi = mid-1;
        }
        return lo;
      }
    }

    const fileInput = document.getElementById('file');
    const messageEl = document.getElementById('message');
    const statsEl = document.getElementById('stats');
    const resetBtn = document.getElementById('resetBtn');
    const zoomModeBtn = document.getElementById('zoomModeBtn');
    const zoomClearBtn = document.getElementById('zoomClearBtn');
    const mapBtn = document.getElementById('mapBtn');
    const smoothSlider = document.getElementById('smoothSlider');
    const smoothText = document.getElementById('smoothText');
    const deviceNameEl = document.getElementById('deviceName');
    const activityTimeEl = document.getElementById('activityTime');

    const canvas = document.getElementById('chart');
    const chart = new LineChart(canvas);

    const toggles = {
      hr:   document.getElementById('toggle-hr'),
      core: document.getElementById('toggle-core'),
      skin: document.getElementById('toggle-skin'),
      hsi:  document.getElementById('toggle-hsi'),
      dist: document.getElementById('toggle-dist'),
      pace: document.getElementById('toggle-pace'),
      cad:  document.getElementById('toggle-cad'),
      trim: document.getElementById('toggle-trim'),
      xaxis: document.getElementById('toggle-xaxis'),
    };

    const toggleStates = {
      hr:   document.getElementById('state-hr'),
      core: document.getElementById('state-core'),
      skin: document.getElementById('state-skin'),
      hsi:  document.getElementById('state-hsi'),
      dist: document.getElementById('state-dist'),
      pace: document.getElementById('state-pace'),
      cad:  document.getElementById('state-cad'),
      trim: document.getElementById('state-trim'),
      xaxis: document.getElementById('state-xaxis'),
    };

    function refreshToggleStates(){
      for (const [key, el] of Object.entries(toggleStates)) {
        const on = !!toggles[key]?.checked;
        if (el) el.textContent = on ? 'On' : 'Off';
      }
    }

    for (const el of Object.values(toggles)) {
      if (el.id !== 'toggle-xaxis') {
        el.addEventListener('change', ()=>{ refreshToggleStates(); renderChart(); updateStatsUI(); });
      }
    }
    toggles.xaxis.addEventListener('change', () => {
      current.xAxisMode = toggles.xaxis.checked ? 'timeOfDay' : 'delta';
      refreshToggleStates();
      renderChart();
    });
    refreshToggleStates();

    let current = {
      records: [],
      devDesc: new Map(),
      fileIds: [],
      deviceInfos: [],
      fileCreators: [],
      manufacturer: null,

      baseTime: 0,

      hrRaw:   [],
      coreRaw: [],
      skinRaw: [],
      hsiRaw:  [],
      distRaw: [],
      paceRaw: [],
      cadRaw:  [],
      elevRaw: [],

      hrSeries:   [],
      coreSeries: [],
      skinSeries: [],
      hsiSeries:  [],
      distSeries: [],
      paceSeries: [],
      cadSeries:  [],
      elevSeries: [],

      coreKey: null,
      skinKey: null,
      coreScale: 1,
      skinScale: 1,
      coreOffset: 0,
      skinOffset: 0,

      tauSec: 0,
      cutoffX: 0,
      selection: null,

      zoomMode: false,
      xAxisMode: 'delta',
    };

    function setSmoothingUI(tau){
      current.tauSec = Math.max(0, tau||0);
      smoothText.textContent = 'Smoothing: ' + fmtS(current.tauSec);
    }
    function sliderToTau(val){
      const pct = clamp(Number(val)||0, 0, 100) / 100;
      return pct * 30;
    }
    smoothSlider.addEventListener('input', ()=>{
      const tau = sliderToTau(smoothSlider.value);
      setSmoothingUI(tau);
      recalcSmoothing();
      renderChart();
      updateStatsUI();
    });

    zoomModeBtn.addEventListener('click', ()=>{
      current.zoomMode = !current.zoomMode;
      chart.setZoomMode(current.zoomMode);
      zoomModeBtn.textContent = current.zoomMode ? 'Zoom: On' : 'Zoom: Off';
      messageEl.textContent = current.zoomMode
        ? 'Zoom mode is ON. Drag to select a time range. Use “Clear Zoom” to reset.'
        : 'Zoom mode is OFF. Slide your finger across the graph to inspect values.';
    });

    zoomClearBtn.addEventListener('click', ()=>{
      current.selection = null;
      zoomClearBtn.disabled = true;
      renderChart();
      updateStatsUI();
    });

    resetBtn.addEventListener('click', ()=>{
      fileInput.value = '';
      messageEl.textContent = 'Load a .FIT file. Zoom mode is OFF by default so you can slide across the graph to see values. Turn Zoom mode ON to drag-select a time range. All parsing and rendering happen locally.';
      statsEl.textContent = '';
      deviceNameEl.textContent = '';
      activityTimeEl.textContent = '';
      activityTimeEl.style.display = 'none';
      mapBtn.disabled = true;
      zoomClearBtn.disabled = true;
      zoomModeBtn.disabled = true;
      resetBtn.disabled = true;
      current = {
        records: [], devDesc: new Map(), fileIds: [], deviceInfos: [], fileCreators: [],
        baseTime: 0,
        hrRaw: [], coreRaw: [], skinRaw: [], hsiRaw: [], distRaw: [], paceRaw: [], cadRaw: [], elevRaw: [],
        hrSeries: [], coreSeries: [], skinSeries: [], hsiSeries: [], distSeries: [], paceSeries: [], cadSeries: [], elevSeries: [],
        coreKey: null, skinKey: null, coreScale: 1, skinScale: 1, coreOffset: 0, skinOffset: 0,
        tauSec: 0, cutoffX: 0, selection: null, zoomMode: false, xAxisMode: 'delta'
      };
      toggles.xaxis.checked = false;
      refreshToggleStates();
      chart.setZoomMode(false);
      chart.xAxisMode = 'delta';
      chart.baseTime = 0;
      smoothSlider.value = "75";
      setSmoothingUI(sliderToTau(75));
      chart.setSeries([], []);
    });

    chart.onSelectRange = (range)=>{
      if (!range) return;
      const x1 = Math.max(range[0], current.cutoffX);
      const x2 = Math.max(x1, range[1]);
      current.selection = [x1, x2];
      zoomClearBtn.disabled = false;
      renderChart();
      updateStatsUI();
    };

    fileInput.addEventListener('change', async (e)=>{
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      resetBtn.disabled = false;
      zoomModeBtn.disabled = false;
      messageEl.textContent = 'Parsing...';
      statsEl.textContent = '';
      activityTimeEl.textContent = '';
      activityTimeEl.style.display = 'none';
      mapBtn.disabled = true;
      zoomClearBtn.disabled = true;

      try {
        const buf = await file.arrayBuffer();
        const parser = new FitParser();
        const { records, devFieldDescriptions, fileIds, deviceInfos, fileCreators } = parser.parse(buf);

        current.records = records;
        current.devDesc = devFieldDescriptions;
        current.fileIds = fileIds;
        current.deviceInfos = deviceInfos;
        current.fileCreators = fileCreators;
        current.manufacturer = (function(){
          const pick = (deviceInfos&&deviceInfos[0]) ? deviceInfos[0] : (fileIds&&fileIds[0]);
          const f = (pick && pick.fields) || {};
          const manuf = (typeof f[2] === 'number') ? f[2] : null;
          // COROS sometimes reports as 294 instead of 167
          if (manuf === 294) return 167;
          return manuf;
        })();

        deviceNameEl.textContent = computeDeviceStringFromCreator(deviceInfos, fileIds, fileCreators);

        if (!records.length) throw new Error('No record data found');

        // Elapsed time
        let firstTs = undefined;
        for (const r of records) {
          if (typeof r.timestamp === 'number' && r.timestamp>0) { firstTs = r.timestamp; break; }
        }
        if (firstTs === undefined) {
          records.forEach((r,i)=>r._elapsed = i);
          messageEl.textContent = 'Warning: No timestamps found. Using sample index as elapsed time.';
        } else {
          records.forEach(r => r._elapsed = (r.timestamp - firstTs));
          messageEl.textContent = 'Parsed. Zoom OFF: slide to inspect; Zoom ON: drag-select.';
        }
        current.baseTime = firstTs || 0;

        if (current.baseTime > 0) {
          const lastElapsed = records.length ? records[records.length - 1]._elapsed : 0;
          const startTime = new Date((current.baseTime + FIT_EPOCH_OFFSET) * 1000);
          const endTime = new Date((current.baseTime + lastElapsed + FIT_EPOCH_OFFSET) * 1000);
          activityTimeEl.textContent = `Activity Date: ${fmtDate(startTime)} | Time: ${fmtTOD(startTime)} - ${fmtTOD(endTime)}`;
          activityTimeEl.style.display = 'block';
        } else {
          activityTimeEl.textContent = '';
          activityTimeEl.style.display = 'none';
        }

        // Extract base fields
        const hrRaw = [];
        const distKmRaw = [];
        const paceRaw = [];
        const cadRaw = [];
        const elevRaw = [];

        let prevDcm = null;
        let prevT = null;

        for (const r of records) {
          const t = r._elapsed;

          const hr = r.fields[3];
          if (typeof hr === 'number' && hr>0 && hr<255) hrRaw.push({x:t, y:hr});

          const c = r.fields[4];
          if (typeof c === 'number' && isFinite(c)) {
            let cadVal = c;
            if (current.manufacturer === 1 || current.manufacturer === 167) cadVal = c * 2; // Garmin & COROS cadence in steps/stride -> spm
            cadRaw.push({x:t, y: cadVal});
          }

          const dRaw = r.fields[5];
          if (typeof dRaw === 'number' && isFinite(dRaw)) {
            const dKm = dRaw / 100000; // cm -> km
            distKmRaw.push({x:t, y:dKm});
          }

          // Pace: prefer field 6 (speed) when reliable; otherwise try field 134; otherwise distance delta
          const rawEnh134 = r.fields[134];
          const rawSpeed = r.fields[6]; // may be scaled
          let pace = NaN;

          const decodeSpeed = (v)=>{
            if (typeof v !== 'number' || !isFinite(v)) return NaN;
            if (v > 25) return v/1000; // scaled by 1000
            return v;
          };
          const fromSpeed = (v)=>{
            const s = decodeSpeed(v);
            return (typeof s==='number' && isFinite(s) && s>0.05) ? (1000/s)/60 : NaN;
          };

          // Use field 6 first if plausible (>0.05 m/s)
          if (rawSpeed !== undefined) pace = fromSpeed(rawSpeed);
          // Else try field 134, but only if plausible
          if (!isFinite(pace) && rawEnh134 !== undefined) {
            const s134 = decodeSpeed(rawEnh134);
            if (isFinite(s134) && s134>0.05) pace = (1000/s134)/60;
          }

          if (!isFinite(pace)) {
            if (typeof dRaw === 'number' && isFinite(dRaw) && prevDcm!=null && prevT!=null) {
              const dd_cm = dRaw - prevDcm;
              const dt = t - prevT;
              if (dt > 0 && dd_cm >= 0) {
                const v = (dd_cm/100) / dt; // m/s
                if (v > 0.05) pace = (1000/v)/60;
              }
            }
          }
          paceRaw.push({x:t, y: isFinite(pace) ? pace : NaN});

          // Enhanced altitude (meters, can be negative)
          const enhancedAlt = r.fields[78];
          if (typeof enhancedAlt === 'number' && isFinite(enhancedAlt)) {
            elevRaw.push({x:t, y: enhancedAlt});
          }

          if (typeof dRaw === 'number' && isFinite(dRaw)) { prevDcm = dRaw; prevT = t; }
        }
        current.hrRaw = hrRaw;
        current.distRaw = distKmRaw;
        current.paceRaw = paceRaw;
        current.cadRaw = cadRaw;

        // Developer fields: Core/Skin temps
        const allDevKeys = new Set();
        for (const rec of records) for (const k in rec.dev) allDevKeys.add(k);
        const candidates = Array.from(allDevKeys);

        let coreKey = null, skinKey = null;

        // COROS specific: look for temperature developer fields with various naming patterns
        if (current.manufacturer === 167) {
          let coreDevKey = null, skinDevKey = null;
          
          // Search for temperature fields in developer data
          for (const [k, desc] of devFieldDescriptions.entries()) {
            const name = (desc.name || '').toLowerCase().trim();
            
            // Core temperature patterns: 'core temperature', 'core_temperature', 'XX_core_temperature'
            if ((name.includes('core') && name.includes('temperature')) || 
                name.includes('core_temperature') || 
                /^\d{2}_core_temperature$/.test(name)) {
              coreDevKey = k;
            }
            
            // Skin temperature patterns: 'skin temperature', 'skin_temperature', 'XX_skin_temperature'  
            if ((name.includes('skin') && name.includes('temperature')) || 
                name.includes('skin_temperature') || 
                /^\d{2}_skin_temperature$/.test(name)) {
              skinDevKey = k;
            }
          }
          
          const coreRawCoros = [];
          const skinRawCoros = [];
          
          // Extract temperature data if fields found
          if (coreDevKey) {
            const desc = devFieldDescriptions.get(coreDevKey) || {};
            const scale = (Number.isFinite(desc.scale) && desc.scale !== 0) ? desc.scale : 0.01; // default /100
            const offset = Number.isFinite(desc.offset) ? desc.offset : 0;
            
            for (const r of records) {
              const v = r.dev[coreDevKey];
              if (typeof v === 'number' && isFinite(v) && v !== 0) {
                coreRawCoros.push({x: r._elapsed, y: v * scale + offset});
              }
            }
          }
          
          if (skinDevKey) {
            const desc = devFieldDescriptions.get(skinDevKey) || {};
            const scale = (Number.isFinite(desc.scale) && desc.scale !== 0) ? desc.scale : 0.05; // default /20
            const offset = Number.isFinite(desc.offset) ? desc.offset : 0;
            
            for (const r of records) {
              const v = r.dev[skinDevKey];
              if (typeof v === 'number' && isFinite(v) && v !== 0) {
                skinRawCoros.push({x: r._elapsed, y: v * scale + offset});
              }
            }
          }
          
          // Only use COROS temperature data if we found actual temperature fields
          if (coreRawCoros.length >= 2 || skinRawCoros.length >= 2) {
            current.coreRaw = coreRawCoros;
            current.skinRaw = skinRawCoros;
          }
          // Note: If no temperature fields found, the app will fall back to generic developer field detection
        }
        function descFor(k){ return devFieldDescriptions.get(k) || {}; }
        function looksLikeCore(d){ return d && d.name && /core/i.test(d.name); }
        function looksLikeSkin(d){ return d && d.name && /skin/i.test(d.name); }
        function unitsC(d){ return d && d.units && /c|°/i.test(d.units); }
        for (const k of candidates) {
          const d = descFor(k);
          if (unitsC(d) && looksLikeCore(d)) coreKey = coreKey || k;
          if (unitsC(d) && looksLikeSkin(d)) skinKey = skinKey || k;
        }

        function seriesFromKey(key){
          if (!key) return [];
          const arr=[];
          const desc = devFieldDescriptions.get(key) || {};
          const scaleFromDesc = (Number.isFinite(desc.scale) && desc.scale!==0) ? desc.scale : 1;
          const offsetFromDesc = Number.isFinite(desc.offset) ? desc.offset : 0;
          for (const rec of records) {
            const v = rec.dev[key];
            if (typeof v === 'number' && isFinite(v)) {
              const y = v * scaleFromDesc + offsetFromDesc;
              arr.push({x:rec._elapsed, y});
            }
          }
          return arr;
        }

        const devSeriesByKey = new Map();
        for (const k of candidates) devSeriesByKey.set(k, seriesFromKey(k));

        function guessTempKey(excludeKey=null){
          let bestKey=null, bestScore=-Infinity, bestScale=1, bestOffset=0;
          for (const k of candidates) {
            if (k===excludeKey) continue;
            const arr = devSeriesByKey.get(k);
            if (!arr || arr.length<5) continue;
            const ys = arr.map(p=>p.y).filter(Number.isFinite).slice().sort((a,b)=>a-b);
            const mid = ys[Math.floor(ys.length/2)];
            let score = -Math.abs(mid-37); let scale=1; let offset=0;
            const d = descFor(k);
            if (Number.isFinite(d.scale) && d.scale !== 0) scale = d.scale;
            if (Number.isFinite(d.offset)) offset = d.offset;
            if (unitsC(d)) score += 2;
            if (looksLikeCore(d) || looksLikeSkin(d)) score += 1;
            if (score > bestScore) {bestScore=score; bestKey=k; bestScale=scale; bestOffset=offset;}
          }
          return {key:bestKey, scale:bestScale, offset:bestOffset};
        }
        if (!coreKey) { const g = guessTempKey(null); coreKey = g.key; current.coreScale = g.scale || 1; current.coreOffset = g.offset || 0; }
        if (!skinKey) { const g = guessTempKey(coreKey); skinKey = g.key; current.skinScale = g.scale || 1; current.skinOffset = g.offset || 0; }

        function scaledSeries(key, scale=1, offset=0){
          if (!key) return [];
          const arr = [];
          for (const rec of records) {
            const v = rec.dev[key];
            if (typeof v === 'number' && isFinite(v)) {
              const y = v*scale + offset;
              if (y > -1000 && y < 1000) arr.push({x:rec._elapsed, y});
            }
          }
          return arr;
        }
        let coreRaw = scaledSeries(coreKey, current.coreScale, current.coreOffset||0);
        let skinRaw = scaledSeries(skinKey, current.skinScale, current.skinOffset||0);

        function adjustIfNeeded(series){
          if (!series.length) return {series, scale:1};
          const ys = series.map(p=>p.y).sort((a,b)=>a-b);
          const mid = ys[Math.floor(ys.length/2)];
          if (mid > 60) return {series: series.map(p=>({x:p.x,y:p.y/100})), scale:0.01};
          if (mid < 5 && mid > 0.05) return {series: series.map(p=>({x:p.x,y:p.y*10})), scale:10};
          return {series, scale:1};
        }
        if (!coreRaw.length && coreKey) { const alt = adjustIfNeeded(seriesFromKey(coreKey)); coreRaw = alt.series; current.coreScale *= alt.scale; /* offset remains user-controlled */ }
        if (!skinRaw.length && skinKey) { const alt = adjustIfNeeded(seriesFromKey(skinKey)); skinRaw = alt.series; current.skinScale *= alt.scale; /* offset remains user-controlled */ }

        current.coreKey = coreKey || null;
        current.skinKey = skinKey || null;
        current.coreRaw = coreRaw;
        current.skinRaw = skinRaw;

        // HSI detection: "heat strain index"
        const hsiKey = detectHSIKey(devFieldDescriptions);
        current.hsiRaw = [];
        if (hsiKey) {
          for (const rec of records) {
            const v = rec.dev[hsiKey];
            if (typeof v === 'number' && isFinite(v)) current.hsiRaw.push({x:rec._elapsed, y:clamp(v, 0, 5)});
          }
        }

        // If no base enhanced_altitude, try dev field by name
        if (!elevRaw.length) {
          const elevKey = detectEnhancedAltitudeDevKey(devFieldDescriptions);
          if (elevKey) {
            for (const rec of records) {
              const v = rec.dev[elevKey];
              if (typeof v === 'number' && isFinite(v)) elevRaw.push({x:rec._elapsed, y:v});
            }
          }
        }
        current.elevRaw = elevRaw;

        const tau = sliderToTau(smoothSlider.value);
        setSmoothingUI(tau);
        recalcSmoothing();

        updateCutoff();

        current.selection = null;
        zoomClearBtn.disabled = true;
        renderChart();
        updateStatsUI();

        const parts = [];
        parts.push('Parsed ' + (records.length) + ' records. Zoom OFF: slide to inspect; Zoom ON: drag-select.');
        if (!current.hrRaw.length) parts.push('No heart rate found.');
        if (!current.coreRaw.length) parts.push('Core temp not auto-detected. Use “Map Fields”.');
        if (!current.skinRaw.length) parts.push('Skin temp not auto-detected. Use “Map Fields”.');
        if (!current.hsiRaw.length) parts.push('Heat Strain Index not found (developer field “heat strain index”).');
        if (!current.elevRaw.length) parts.push('Enhanced altitude not found; elevation background will be hidden.');
        messageEl.textContent = parts.join(' ');

        mapBtn.disabled = (candidates.length === 0);
      } catch (err) {
        console.error(err);
        messageEl.innerHTML = '<span class="error">Error: ' + (err && err.message ? err.message : String(err)) + '</span>';
      }
    });

    function detectHSIKey(devDesc){
      for (const [k, d] of devDesc.entries()) {
        const name = (d.name||'').toLowerCase().trim();
        if (!name) continue;
        if (name === 'heat strain index') return k;
        if ((name.includes('heat') && name.includes('strain')) || name.includes('hsi')) return k;
      }
      return null;
    }

    function detectEnhancedAltitudeDevKey(devDesc){
      for (const [k, d] of devDesc.entries()) {
        const nm = (d.name||'').toLowerCase().trim();
        if (!nm) continue;
        if (nm === 'enhanced altitude') return k;
        if (nm.includes('enhanced') && nm.includes('altitude')) return k;
      }
      return null;
    }

    function smoothZeroPhase(points, tauSec){
      if (!points || points.length === 0 || !isFinite(tauSec) || tauSec <= 0) return (points||[]).slice();

      let i0 = 0;
      while (i0 < points.length && !Number.isFinite(points[i0].y)) i0++;
      if (i0 >= points.length) return points.map(p=>({x:p.x, y:NaN}));

      const f = new Array(points.length);
      let y = points[i0].y;
      for (let i=0;i<=i0;i++) f[i] = {x:points[i].x, y};
      for (let i=i0+1; i<points.length; i++){
        const dt = Math.max(0, points[i].x - points[i-1].x);
        const alpha = 1 - Math.exp(-dt / tauSec);
        const v = Number.isFinite(points[i].y) ? points[i].y : y;
        y = y + alpha * (v - y);
        f[i] = {x: points[i].x, y};
      }

      const b = new Array(points.length);
      let yb = f[points.length-1].y;
      b[points.length-1] = {x: f[points.length-1].x, y: yb};
      for (let i=points.length-2; i>=0; i--){
        const dt = Math.max(0, f[i+1].x - f[i].x);
        const alpha = 1 - Math.exp(-dt / tauSec);
        const v = Number.isFinite(f[i].y) ? f[i].y : yb;
        yb = yb + alpha * (v - yb);
        b[i] = {x: f[i].x, y: yb};
      }
      return b;
    }

    function recalcSmoothing(){
      const tau = current.tauSec || 0;
      current.hrSeries   = smoothZeroPhase(current.hrRaw,   tau);
      current.coreSeries = smoothZeroPhase(current.coreRaw, tau);
      current.skinSeries = smoothZeroPhase(current.skinRaw, tau);
      current.hsiSeries  = smoothZeroPhase(current.hsiRaw,  tau);
      current.distSeries = smoothZeroPhase(current.distRaw, tau);
      current.paceSeries = smoothZeroPhase(current.paceRaw, tau);
      current.cadSeries  = smoothZeroPhase(current.cadRaw,  tau);
      current.elevSeries = smoothZeroPhase(current.elevRaw, Math.min(10, tau || 3));
    }

    function updateCutoff(){
      let cut = 0;
      const eps = 1e-9;
      if (current.coreRaw && current.coreRaw.length) {
        for (const p of current.coreRaw) {
          if (Number.isFinite(p.y) && p.y > 0 + eps) { cut = p.x; break; }
        }
      }
      current.cutoffX = cut;
    }

    function inView(x){
      if (toggles.trim && toggles.trim.checked) {
        if (x < current.cutoffX) return false;
      }
      if (current.selection) {
        if (x < current.selection[0] || x > current.selection[1]) return false;
      }
      return true;
    }
    function filterPoints(arr){ return (arr||[]).filter(p => inView(p.x)); }

    function renderChart(){
      chart.xAxisMode = current.xAxisMode;
      chart.baseTime = current.baseTime;

      const series = [
        { id:'core', name:'Core Temp',  color:getVar('--core','#1e88e5'), axis:'left',  visible: toggles.core.checked, points: filterPoints(current.coreSeries), fmt:(v)=> `${(Math.round(v*100)/100).toFixed(2)} °C` },
        { id:'skin', name:'Skin Temp',  color:getVar('--skin','#fb8c00'), axis:'left',  visible: toggles.skin.checked, points: filterPoints(current.skinSeries), fmt:(v)=> `${(Math.round(v*100)/100).toFixed(2)} °C` },

        { id:'hr',   name:'Heart Rate', color:getVar('--hr','#e53935'),   axis:'right', visible: toggles.hr.checked,   points: filterPoints(current.hrSeries),   fmt:(v)=> `${Math.round(v)} bpm` },
        { id:'hsi',  name:'HSI',        color:getVar('--hsi','#ab47bc'),  axis:'right', visible: toggles.hsi.checked,  points: filterPoints(current.hsiSeries),  fmt:(v)=> Number.isFinite(v)? (Math.round(v*100)/100).toFixed(2):'--' },
        { id:'dist', name:'Distance',   color:getVar('--dist','#66bb6a'), axis:'right', visible: toggles.dist.checked, points: filterPoints(current.distSeries), fmt:(v)=> Number.isFinite(v)? (Math.round(v*100)/100).toFixed(2)+' km':'--' },
        { id:'pace', name:'Pace',       color:getVar('--pace','#26c6da'), axis:'right', visible: toggles.pace.checked, points: filterPoints(current.paceSeries), fmt:(v)=> fmtPace(v) },
        { id:'cad',  name:'Cadence',    color:getVar('--cad','#ffd54f'),  axis:'right', visible: toggles.cad.checked,  points: filterPoints(current.cadSeries),  fmt:(v)=> Number.isFinite(v)? Math.round(v)+' spm':'--' },
      ];
      const elev = filterPoints(current.elevSeries);
      chart.setSeries(series, elev);
    }

    function arrayMaxInView(arr){
      if (!arr || !arr.length) return null;
      let m = -Infinity;
      for (const p of arr) {
        if (!inView(p.x)) continue;
        if (Number.isFinite(p.y)) m = Math.max(m, p.y);
      }
      return (m===-Infinity) ? null : m;
    }

    function arrayMinInView(arr){
      if (!arr || !arr.length) return null;
      let m = Infinity;
      for (const p of arr) {
        if (!inView(p.x)) continue;
        if (Number.isFinite(p.y)) m = Math.min(m, p.y);
      }
      return (m===Infinity) ? null : m;
    }

    function updateStatsUI(){
      const hrMax   = arrayMaxInView(current.hrRaw);
      const coreMax = arrayMaxInView(current.coreRaw);
      const skinMax = arrayMaxInView(current.skinRaw);

      const parts = [
        `<span>Max Core: <span class="kbd">${coreMax!=null ? (Math.round(coreMax*100)/100).toFixed(2)+' °C' : '--'}</span></span>`,
        `<span>Max Skin: <span class="kbd">${skinMax!=null ? (Math.round(skinMax*100)/100).toFixed(2)+' °C' : '--'}</span></span>`,
        `<span>Max HR: <span class="kbd">${hrMax!=null ? Math.round(hrMax)+' bpm' : '--'}</span></span>`,
        `<span>Window: <span class="kbd">${fmtHMS(viewDuration())}</span></span>`
      ];

      if (toggles.hsi.checked) {
        const h = arrayMaxInView(current.hsiRaw);
        parts.push(`<span>Max HSI: <span class="kbd">${h!=null ? (Math.round(h*100)/100).toFixed(2) : '--'}</span></span>`);
      }
      if (toggles.dist.checked) {
        const d = arrayMaxInView(current.distRaw);
        parts.push(`<span>Max Distance: <span class="kbd">${d!=null ? (Math.round(d*100)/100).toFixed(2)+' km' : '--'}</span></span>`);
      }
      if (toggles.pace.checked) {
        const p = arrayMinInView(current.paceRaw);
        parts.push(`<span>Best Pace: <span class="kbd">${p!=null ? fmtPace(p) : '--'}</span></span>`);
      }
      if (toggles.cad.checked) {
        const c = arrayMaxInView(current.cadRaw);
        parts.push(`<span>Max Cadence: <span class="kbd">${c!=null ? Math.round(c)+' spm' : '--'}</span></span>`);
      }

      statsEl.innerHTML = parts.join(' ');
    }

    function viewDuration(){
      let start = (toggles.trim && toggles.trim.checked) ? current.cutoffX : 0;
      let end = (current.records.length ? current.records[current.records.length-1]._elapsed : 0);
      if (current.selection) {
        start = Math.max(start, current.selection[0]);
        end = Math.min(end, current.selection[1]);
      }
      return Math.max(0, end - start);
    }

    const modalBackdrop = document.getElementById('modalBackdrop');
    const modalEl = document.querySelector('.modal');
    const coreSelect = document.getElementById('coreSelect');
    const skinSelect = document.getElementById('skinSelect');
    const coreScaleInput = document.getElementById('coreScale');
    const skinScaleInput = document.getElementById('skinScale');
    const coreOffsetInput = document.getElementById('coreOffset');
    const skinOffsetInput = document.getElementById('skinOffset');
    const cancelMap = document.getElementById('cancelMap');
    const applyMap = document.getElementById('applyMap');
    const mapHint = document.getElementById('mapHint');

    let lastFocusEl = null;

    mapBtn.addEventListener('click', ()=>{
      const devKeys = getAllDeveloperKeys(current.records);
      if (devKeys.length === 0) {
        messageEl.textContent = 'No developer fields found in this file.';
        return;
      }
      coreSelect.innerHTML = '';
      skinSelect.innerHTML = '';
      const opts = devKeys.map(k => {
        const desc = current.devDesc.get(k) || {};
        const label = niceDevLabel(k, desc, current.records);
        return {k, label};
      });
      for (const {k,label} of opts) {
        const o1 = document.createElement('option'); o1.value = k; o1.textContent = label; coreSelect.appendChild(o1);
        const o2 = document.createElement('option'); o2.value = k; o2.textContent = label; skinSelect.appendChild(o2);
      }
      if (current.coreKey) coreSelect.value = current.coreKey;
      if (current.skinKey) skinSelect.value = current.skinKey;
      coreScaleInput.value = String(current.coreScale || 1);
      skinScaleInput.value = String(current.skinScale || 1);
      coreOffsetInput.value = String(current.coreOffset || 0);
      skinOffsetInput.value = String(current.skinOffset || 0);
      mapHint.innerHTML = sampleHintHTML(current.records, devKeys);

      lastFocusEl = document.activeElement;
      modalBackdrop.style.display = 'flex';
      setTimeout(()=>{ modalEl.focus(); }, 0);
    });

    function closeModal(){
      modalBackdrop.style.display='none';
      if (lastFocusEl && typeof lastFocusEl.focus === 'function') lastFocusEl.focus();
    }

    cancelMap.addEventListener('click', closeModal);

    applyMap.addEventListener('click', ()=>{
      const coreKey = coreSelect.value || null;
      const skinKey = skinSelect.value || null;
      let coreScale = parseFloat(coreScaleInput.value); if (!Number.isFinite(coreScale) || coreScale===0) coreScale = 1;
      let skinScale = parseFloat(skinScaleInput.value); if (!Number.isFinite(skinScale) || skinScale===0) skinScale = 1;
      let coreOffset = parseFloat(coreOffsetInput.value); if (!Number.isFinite(coreOffset)) coreOffset = 0;
      let skinOffset = parseFloat(skinOffsetInput.value); if (!Number.isFinite(skinOffset)) skinOffset = 0;

      current.coreKey = coreKey; current.skinKey = skinKey;
      current.coreScale = coreScale; current.skinScale = skinScale;
      current.coreOffset = coreOffset; current.skinOffset = skinOffset;

      const coreRaw = [];
      const skinRaw = [];
      for (const r of current.records) {
        if (coreKey && typeof r.dev[coreKey] === 'number' && isFinite(r.dev[coreKey])) {
          coreRaw.push({x:r._elapsed, y:r.dev[coreKey]*coreScale + coreOffset});
        }
        if (skinKey && typeof r.dev[skinKey] === 'number' && isFinite(r.dev[skinKey])) {
          skinRaw.push({x:r._elapsed, y:r.dev[skinKey]*skinScale + skinOffset});
        }
      }
      current.coreRaw = coreRaw;
      current.skinRaw = skinRaw;

      recalcSmoothing();
      updateCutoff();
      renderChart();
      updateStatsUI();

      const parts = [];
      parts.push('Updated mapping.');
      if (!coreRaw.length) parts.push('No core temp points with this mapping.');
      if (!skinRaw.length) parts.push('No skin temp points with this mapping.');
      messageEl.textContent = parts.join(' ');

      closeModal();
    });

    modalBackdrop.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape') { e.preventDefault(); closeModal(); }
      if (e.key === 'Tab') {
        // simple focus trap: keep focus within modal
        const focusables = modalBackdrop.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        const list = Array.from(focusables).filter(el=> el.offsetParent !== null);
        if (list.length === 0) return;
        const first = list[0], last = list[list.length-1];
        if (e.shiftKey) {
          if (document.activeElement === first) { e.preventDefault(); last.focus(); }
        } else {
          if (document.activeElement === last) { e.preventDefault(); first.focus(); }
        }
      }
    });

    function getAllDeveloperKeys(records){
      const set = new Set();
      for (const r of records) for (const k in r.dev) set.add(k);
      return Array.from(set);
    }

    function niceDevLabel(key, desc, records){
      const sample = (() => { for (const r of records) if (typeof r.dev[key] === 'number' && isFinite(r.dev[key])) return r.dev[key]; return null; })();
      const name = desc?.name ? desc.name : 'Field ' + key;
      const units = desc?.units ? ' ' + desc.units : '';
      const val = (sample!=null) ? ` [ex: ${Math.round(sample*100)/100}]` : '';
      return name + (units ? ` (${units.trim()})` : '') + ' -- ' + key + val;
    }

    function sampleHintHTML(records, devKeys){
      let html = 'First sample values per field: ';
      const parts = [];
      for (const k of devKeys) {
        let v=null;
        for (const r of records) if (typeof r.dev[k]==='number') { v=r.dev[k]; break; }
        if (v!=null) parts.push(`<span class="kbd">${k}</span>: ${Math.round(v*100)/100}`);
      }
      html += parts.join(', ');
      return html;
    }

    function computeDeviceStringFromCreator(deviceInfos, fileIds, fileCreators){
      let picked = null;
      for (const d of deviceInfos||[]) {
        const f = d.fields||{};
        if (f[0]===0) { picked = d; break; }
      }
      if (!picked && deviceInfos && deviceInfos.length) picked = deviceInfos[0];

      let manuf = null, product = null, serial = null, sw = null, productName = null; let productStr = null;
      if (picked) {
        const f = picked.fields||{};
        manuf = f[2];
        product = f[4];
        serial = f[3];
        sw = f[5];
        if (typeof f[27] === 'string' && f[27].trim()) productName = f[27].trim(); // product_name
      }
      if ((manuf==null || product==null || serial==null) && fileIds && fileIds.length) {
        const f = fileIds[0].fields||{};
        if (manuf==null) manuf = f[1];
        if (product==null) product = f[2];
        if (serial==null) serial = f[3];
      }
      if (sw==null && fileCreators && fileCreators.length) {
        const fc = fileCreators[0].fields||{};
        if (typeof fc[0] === 'number') {
          sw = fc[0];
        }
      }
      // Normalize sw to xx.yy by dividing by 100 when numeric
      if (typeof sw === 'number') sw = sw/100;

      const brandStr = (typeof manuf === 'number' && MANUFACTURERS[manuf]) ? MANUFACTURERS[manuf] : (manuf!=null ? String(manuf) : 'Unknown');

      // Prefer product_name string if available (e.g., 'fr55'), with normalization
      let prodStr = productName || null;
      if (!prodStr) {
        // Fallback to numeric code (product ID)
        if (brandStr === 'Garmin' && product!=null) {
          const garminMap = {
            // Common Forerunners (subset; extend as needed)
            2691: 'Forerunner 45', 2693: 'Forerunner 45S',
            3869: 'Forerunner 55',
            2713: 'Forerunner 245', 2729: 'Forerunner 245 Music',
            3315: 'Forerunner 255', 3321: 'Forerunner 255S', 3329: 'Forerunner 255 Music',
            2711: 'Forerunner 645', 2712: 'Forerunner 645 Music',
            3510: 'Forerunner 745',
            2710: 'Forerunner 935',
            3284: 'Forerunner 945', 3512: 'Forerunner 945 LTE',
            4000: 'Forerunner 955', 4015: 'Forerunner 965',
            // Fenix (partial examples)
            3192: 'Fenix 6', 3195: 'Fenix 6 Pro', 3358: 'Fenix 7', 3891: 'Fenix 7 Pro',
            // Edge (partial examples)
            1030: 'Edge 1030', 2962: 'Edge 530', 3003: 'Edge 830',
            // Venu/Vivoactive (partial examples)
            3785: 'Venu 2', 3812: 'Venu 2S', 3482: 'Vivoactive 4',
          };
          prodStr = garminMap[product] || String(product);
        } else {
          prodStr = (product!=null ? String(product) : 'Unknown');
        }
      }
      prodStr = normalizeProductName(brandStr, prodStr);

      // Build optional details only if present
      const details = [];
      if (sw!=null) {
        let swStr = String(sw);
        if (typeof sw === 'number' && sw % 1 !== 0) swStr = (Math.round(sw*100)/100).toFixed(2);
        details.push(`sw version = ${swStr}`);
      }
      if (serial!=null) {
        details.push(`serial = ${String(serial)}`);
      }
      const detailsStr = details.length ? ` (${details.join(', ')})` : '';
      return `${brandStr} ${prodStr}${detailsStr}`;
    }

    setSmoothingUI(sliderToTau(smoothSlider.value));
    chart.setZoomMode(false);
  </script>
</body>
</html>