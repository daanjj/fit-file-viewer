<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>FIT Viewer v1.1.0</title>
<style>
  :root{
    --bg:#0f1115;
    --card:#171a21;
    --muted:#8a94a7;
    --text:#e7ecf3;
    --accent:#1976d2;
    --accent-2:#2e7d32;
    --danger:#d32f2f;
    --grid:#233047;
    --chip:#222734;
    --chip-active:#2a3142;

    --hsi-green:#e6f5ea;
    --hsi-orange:#fff1e0;
    --hsi-red:#ffe7e7;

    --elev-stroke: rgba(60,60,60,0.28);
    --elev-fill: rgba(60,60,60,0.09);
  }
  * { box-sizing: border-box; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  a { color: var(--accent); text-decoration: none; }
  header { position: sticky; top: 0; z-index: 50; background: var(--bg); border-bottom: 1px solid #1b2333; }
  .wrap { max-width: 980px; margin: 0 auto; padding: 12px; }
  .title { font-weight: 700; font-size: 18px; margin: 0 0 8px; }
  .device-line { color: var(--muted); font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .controls { display: grid; grid-template-columns: 1fr; gap: 8px; margin-top: 8px; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
  .file { background: var(--card); padding: 8px; border-radius: 8px; display:flex; align-items:center; gap:8px; }
  .btn { background: var(--chip); color: var(--text); border: 1px solid #2b3245; padding: 6px 10px; border-radius: 8px; cursor: pointer; font-size: 14px; }
  .btn.primary { background: var(--accent); border-color: transparent; color: white; }
  .btn.ghost { background: transparent; }
  .btn.danger { background: var(--danger); color: white; border-color: transparent; }
  .btn:disabled { opacity: 0.5; cursor: default; }
  .chip { background: var(--chip); color: var(--text); border: 1px solid #2b3245; padding: 4px 8px; border-radius: 999px; cursor: pointer; font-size: 12px; }
  .chip.active { background: var(--chip-active); }
  .sticky-bar { position: sticky; top: 52px; z-index: 40; background: var(--bg); padding: 8px 0; border-bottom: 1px solid #1b2333; }
  .slider { display:flex; align-items:center; gap:8px; }
  input[type="range"] { width: 160px; }
  .maxima { display:flex; gap:8px; flex-wrap: wrap; font-size: 12px; color: var(--muted); }
  .card { background: var(--card); border: 1px solid #253046; border-radius: 12px; padding: 8px; margin: 12px; }
  .card h3 { margin: 6px 4px 8px; font-size: 14px; color:#c9d4e5; }
  .chart-wrap { position: relative; width: 100%; overflow: hidden; border-radius: 8px; background: #0c0f14; }
  canvas { display:block; width: 100%; height: 260px; }
  .msg { margin: 6px 4px 0; font-size: 12px; color: var(--muted); max-height: 48px; overflow: auto; }
  .legend { display:flex; gap: 6px; flex-wrap: wrap; margin-top: 6px; }
  .legend .swatch { width: 10px; height: 10px; border-radius: 2px; margin-right: 6px; display:inline-block; vertical-align: -1px; }
  .row.wrap { flex-wrap: wrap; }
  .map-wrap { position: relative; width: 100%; overflow: hidden; border-radius: 8px; background: #0c0f14; }
  .map-wrap canvas { height: 300px; }
  .hidden { display:none !important; }

  .modal-backdrop { position: fixed; inset:0; background: rgba(0,0,0,0.5); display:none; align-items: center; justify-content: center; z-index: 100; }
  .modal { background: var(--card); border: 1px solid #2b3245; border-radius: 12px; width: min(640px, 92vw); padding: 12px; }
  .modal h4 { margin: 0 0 8px; }
  .modal .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .field { display:flex; flex-direction: column; gap: 4px; font-size: 13px; }
  .field select, .field input { background:#0e1320; color: var(--text); border:1px solid #2b3245; border-radius: 6px; padding: 6px; }
  .modal .actions { display:flex; gap:8px; justify-content:flex-end; margin-top: 10px; }
  @media (min-width: 700px){
    canvas { height: 360px; }
    .map-wrap canvas { height: 420px; }
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="title">FIT Viewer v1.1.0</div>
    <div id="deviceLine" class="device-line">No file loaded</div>
    <div class="controls">
      <div class="row">
        <label class="file">
          <input id="fileInput" type="file" accept=".fit" style="display:none">
          <span class="btn">Choose .FIT</span>
        </label>
        <button id="resetBtn" class="btn ghost">Reset</button>
        <button id="mapFieldsBtn" class="btn ghost" disabled>Map Fields</button>
        <button id="zoomToggle" class="btn">Zoom: OFF</button>
        <button id="clearZoom" class="btn" disabled>Clear Zoom</button>
      </div>
      <div class="row legend" id="legend"></div>
    </div>
  </div>
  <div class="sticky-bar">
    <div class="wrap">
      <div class="row">
        <div class="slider">
          <span>Smoothing</span>
          <input id="smoothRange" type="range" min="0" max="30" step="1" value="0">
          <span id="smoothVal">0 s</span>
        </div>
        <div class="row">
          <button id="toggleHSIbg" class="chip hidden">HSI Background</button>
          <button id="toggleElevBG" class="chip hidden">Elevation Backdrop</button>
        </div>
      </div>
      <div id="maxima" class="maxima"></div>
    </div>
  </div>
</header>

<main>
  <section class="card">
    <h3>Chart</h3>
    <div class="chart-wrap">
      <canvas id="chart"></canvas>
    </div>
    <div class="msg" id="message">Load a .fit file to view data. Slide finger to inspect values. Toggle Zoom to select a time range and tap Clear Zoom to reset.</div>
  </section>

  <section id="routeSection" class="card hidden">
    <h3>Route</h3>
    <div class="map-wrap">
      <canvas id="routeCanvas"></canvas>
    </div>
    <div class="msg">Offline route view: tight fit to your track; no external tiles.</div>
  </section>
</main>

<div id="modalBackdrop" class="modal-backdrop">
  <div class="modal">
    <h4>Developer Field Mapping</h4>
    <p style="color:var(--muted)">Select developer fields for Core and Skin temperatures. Apply scale factors if needed (e.g., 0.01 for centi-degrees).</p>
    <div class="grid">
      <div class="field">
        <label for="coreField">Core Temp Field</label>
        <select id="coreField"></select>
      </div>
      <div class="field">
        <label for="coreScale">Core Scale</label>
        <input id="coreScale" type="number" step="0.0001" value="1">
      </div>
      <div class="field">
        <label for="skinField">Skin Temp Field</label>
        <select id="skinField"></select>
      </div>
      <div class="field">
        <label for="skinScale">Skin Scale</label>
        <input id="skinScale" type="number" step="0.0001" value="1">
      </div>
    </div>
    <div class="actions">
      <button id="cancelMap" class="btn">Cancel</button>
      <button id="applyMap" class="btn primary">Apply</button>
    </div>
  </div>
</div>

<script>
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const dpr = () => (window.devicePixelRatio || 1);
const COLORS = {
  core: '#ff6e40', skin: '#f9a825', hr: '#ec407a',
  pace: '#42a5f5', distance: '#26a69a', cadence: '#ab47bc', hsi: '#ef5350'
};

const state = {
  fileName: null, deviceLine: 'No file loaded',
  records: [], t0: null, viewStart: 0, viewEnd: 0,
  zoomActive: false, selecting: null, smoothingSec: 0,
  show: { core:true, skin:true, hr:true, hsi:false, distance:false, pace:false, cadence:false },
  showHSIbg:false, showElevBG:false,
  devFields: [], map: { coreKey:null, coreScale:1, skinKey:null, skinScale:1 },
  hasRoute: false
};

function semicirclesToDeg(v){ return v * (180 / Math.pow(2,31)); }

class Bin {
  constructor(buf){ this.dv=new DataView(buf); this.o=0; this.le=true; }
  u8(){ const v=this.dv.getUint8(this.o); this.o+=1; return v; }
  i8(){ const v=this.dv.getInt8(this.o); this.o+=1; return v; }
  u16(){ const v=this.dv.getUint16(this.o,this.le); this.o+=2; return v; }
  u32(){ const v=this.dv.getUint32(this.o,this.le); this.o+=4; return v; }
  i16(){ const v=this.dv.getInt16(this.o,this.le); this.o+=2; return v; }
  i32(){ const v=this.dv.getInt32(this.o,this.le); this.o+=4; return v; }
  f32(){ const v=this.dv.getFloat32(this.o,this.le); this.o+=4; return v; }
  f64(){ const v=this.dv.getFloat64(this.o,this.le); this.o+=8; return v; }
  skip(n){ this.o+=n; } pos(){ return this.o; } seek(n){ this.o=n; } left(){ return this.dv.byteLength - this.o; }
}

async function parseFIT(arrayBuffer){
  const b = new Bin(arrayBuffer);
  if(b.left() < 12) throw new Error('Invalid FIT file');
  const headerSize = b.u8();
  b.u8(); b.u16(); // proto/prof ver
  const dataSize = b.u32();
  const fileType = String.fromCharCode(b.u8(), b.u8(), b.u8(), b.u8());
  if(fileType !== '.FIT') throw new Error('Not a FIT file');
  if(headerSize >= 14) b.u16();
  b.seek(headerSize);

  const baseTypes = {
    0x00:{n:'enum',s:1,r:(dv,o)=>dv.getUint8(o)},
    0x01:{n:'sint8',s:1,r:(dv,o)=>dv.getInt8(o)},
    0x02:{n:'uint8',s:1,r:(dv,o)=>dv.getUint8(o)},
    0x83:{n:'sint16',s:2,r:(dv,o)=>dv.getInt16(o,true)},
    0x84:{n:'uint16',s:2,r:(dv,o)=>dv.getUint16(o,true)},
    0x85:{n:'sint32',s:4,r:(dv,o)=>dv.getInt32(o,true)},
    0x86:{n:'uint32',s:4,r:(dv,o)=>dv.getUint32(o,true)},
    0x07:{n:'string',s:1,r:(dv,o)=>null},
    0x88:{n:'float32',s:4,r:(dv,o)=>dv.getFloat32(o,true)},
    0x89:{n:'float64',s:8,r:(dv,o)=>dv.getFloat64(o,true)},
    0x0A:{n:'uint8z',s:1,r:(dv,o)=>dv.getUint8(o)},
    0x8B:{n:'uint16z',s:2,r:(dv,o)=>dv.getUint16(o,true)},
    0x8C:{n:'uint32z',s:4,r:(dv,o)=>dv.getUint32(o,true)},
    0x0D:{n:'byte',s:1,r:(dv,o)=>dv.getUint8(o)},
    0x8E:{n:'sint64',s:8,r:(dv,o)=>{const lo=dv.getUint32(o,true),hi=dv.getInt32(o+4,true);return hi*2**32+lo}},
    0x8F:{n:'uint64',s:8,r:(dv,o)=>{const lo=dv.getUint32(o,true),hi=dv.getUint32(o+4,true);return hi*2**32+lo}},
    0x90:{n:'uint64z',s:8,r:(dv,o)=>{const lo=dv.getUint32(o,true),hi=dv.getUint32(o+4,true);return hi*2**32+lo}},
  };

  const localDefs = {};
  const devFieldDescs = {};
  const messages = [];
  const deviceInfo = [];
  let fileId=null, fileCreator=null;

  function readString(dv,o,len){
    const bytes = new Uint8Array(dv.buffer, dv.byteOffset + o, len);
    let out=''; for(let i=0;i<len;i++){ const c=bytes[i]; if(c===0) break; out+=String.fromCharCode(c); }
    return out;
  }

  while(b.left() > 2){
    const recHeader = b.u8();
    const isDef = (recHeader & 0x40) !== 0;
    const localNum = recHeader & 0x0F;
    const isDevData = (recHeader & 0x20) !== 0;

    if(isDef){
      b.u8(); // arch
      const globalMsgNum = b.u16();
      const numFields = b.u8();
      const fields=[];
      for(let i=0;i<numFields;i++){
        const fieldNum=b.u8(); const size=b.u8(); const base=b.u8();
        fields.push({fieldNum,size,base});
      }
      const devFields=[];
      if(isDevData){
        const devNum = b.u8();
        for(let i=0;i<devNum;i++){
          const fieldNum=b.u8(); const devDataIndex=b.u8(); const size=b.u8();
          devFields.push({fieldNum,devDataIndex,size});
        }
      }
      localDefs[localNum] = {globalMsgNum, fields, devFields};
    } else {
      const def = localDefs[localNum];
      if(!def){ break; }
      const dv = b.dv; let o = b.pos();
      function readField(fd){
        const bt = baseTypes[fd.base]; const size = fd.size;
        let val = null;
        if(!bt){ /* skip */ }
        else if(bt.n === 'string'){ val = readString(dv, o, size); }
        else { try{ val = bt.r(dv, o); } catch(e){ val=null; } }
        o += size; return val;
      }
      const msg = { global: def.globalMsgNum, fields:{}, dev:{} };
      for(const f of def.fields){ msg.fields[f.fieldNum] = readField(f); }
      for(const f of def.devFields){
        const size = f.size;
        const end = o + size;
        if(end > dv.byteLength){ o = dv.byteLength; break; }
        const arr = new Uint8Array(dv.buffer, dv.byteOffset + o, size);
        let val = 0; const m = Math.min(4, size);
        for(let i=0;i<m;i++){ val |= (arr[i] << (8*i)); }
        o += size;
        msg.dev[`${f.devDataIndex}:${f.fieldNum}`] = val;
      }
      b.seek(o);

      if(msg.global === 206){
        const fnum = msg.fields[3];
        const devIdx = msg.fields[2];
        const name = (typeof msg.fields[0] === 'string') ? msg.fields[0] : '';
        const units = (typeof msg.fields[1] === 'string') ? msg.fields[1] : '';
        const scale = (msg.fields[5] != null && msg.fields[5] !== 0) ? msg.fields[5] : 1;
        const offset = (msg.fields[6] != null) ? msg.fields[6] : 0;
        if(devIdx != null && fnum != null){
          devFieldDescs[`${devIdx}:${fnum}`] = { name, units, scale, offset };
        }
      }
      if(msg.global === 0){ fileId = msg; }
      if(msg.global === 49){ fileCreator = msg; }
      if(msg.global === 23){ deviceInfo.push(msg); }

      messages.push(msg);
    }
  }

  const records = [];
  for(const msg of messages){
    if(msg.global !== 20) continue;
    const f = msg.fields;
    const timestamp = f[253] != null ? (f[253] + 631065600) : null;
    const hr = f[3] ?? null;
    const cadence = f[4] ?? null;
    const distance = f[5] ?? null;
    const speed = f[6] ?? null;
    const enhanced_speed = f[13] ?? null;
    const altitude = f[2] ?? null;
    const enhanced_altitude = f[78] ?? null;
    const position_lat = f[0] ?? null;
    const position_long = f[1] ?? null;
    const dev = {};
    for(const k of Object.keys(msg.dev)){
      const desc = devFieldDescs[k];
      const raw = msg.dev[k];
      if(desc){
        const scaled = (raw - (desc.offset||0)) / (desc.scale || 1);
        dev[k] = { value: scaled, name: desc.name || k, units: desc.units || '' };
      } else {
        dev[k] = { value: raw, name: k, units: '' };
      }
    }
    records.push({ t: timestamp, hr, cadence, distance, speed, enhanced_speed, altitude, enhanced_altitude, position_lat, position_long, dev });
  }

  const devFieldsList = [];
  const seen = new Set();
  for(const msg of messages){
    if(msg.global !== 20) continue;
    for(const k of Object.keys(msg.dev)){
      if(seen.has(k)) continue; seen.add(k);
      const desc = devFieldDescs[k] || {};
      devFieldsList.push({ key:k, name: desc.name || k, units: desc.units || '', example: msg.dev[k] });
    }
  }

  const deviceLine = inferDeviceLine(deviceInfo, fileId, fileCreator);
  return { records, devFieldsList, deviceLine };
}

function inferDeviceLine(deviceInfo, fileId, fileCreator){
  let chosen = null;
  for(const d of deviceInfo){
    const idx = d.fields[2];
    if(idx === 0){ chosen = d; break; }
  }
  let brand=null, product=null, sw=null, serial=null;
  if(chosen){ brand = chosen.fields[1]; product = chosen.fields[3]; sw = chosen.fields[5]; serial = chosen.fields[4]; }
  const brandName = manufacturerName(brand);
  return `${brandName} ${product ?? '?'} (sw version = ${sw ?? '?'}, serial= ${serial ?? '?'})`;
}
function manufacturerName(id){
  const map = { 1:'Garmin',13:'Wahoo',32:'Suunto',37:'Tacx',38:'SRAM',42:'Specialized',47:'Hammerhead',54:'Stages',76:'Polar' };
  if(id == null) return 'Unknown';
  return map[id] || `Manufacturer ${id}`;
}

function prepareData(){
  const recs = state.records;
  const xs = [];
  const series = { core:[], skin:[], hr:[], pace:[], distance:[], cadence:[], hsi:[], elev:[], lat:[], lon:[] };

  let coreKey = state.map.coreKey, skinKey = state.map.skinKey;
  if(!coreKey || !skinKey){
    const candidates = collectDevCandidates();
    if(!coreKey && candidates.core){ coreKey = candidates.core.key; state.map.coreKey = coreKey; state.map.coreScale = candidates.core.scale || 1; }
    if(!skinKey && candidates.skin){ skinKey = candidates.skin.key; state.map.skinKey = skinKey; state.map.skinScale = candidates.skin.scale || 1; }
  }
  let hsiKey = null;
  for(const k of listAllDevKeys()){
    const name = (devName(k)||'').toLowerCase();
    if(name.includes('heat strain') || name === 'hsi' || name.includes('hsi')){ hsiKey = k; break; }
  }

  let hasLatLon = false;
  state.t0 = null;
  for(let i=0;i<recs.length;i++){
    const r = recs[i];
    const t = r.t != null ? r.t : (state.t0 != null ? state.t0 + i : null);
    if(state.t0 == null && t != null) state.t0 = t;
    const elapsed = (state.t0 != null && t != null) ? (t - state.t0) : (i===0 ? 0 : xs[i-1] + 1);

    xs.push(elapsed);

    const core = (coreKey && r.dev[coreKey]) ? r.dev[coreKey].value * (state.map.coreScale||1) : NaN;
    const skin = (skinKey && r.dev[skinKey]) ? r.dev[skinKey].value * (state.map.skinScale||1) : NaN;
    const hr = (r.hr != null && r.hr !== 0) ? r.hr : NaN;

    let dist_km = NaN;
    if(r.distance != null) dist_km = r.distance / 100000;

    let spd = (r.enhanced_speed != null && r.enhanced_speed > 0) ? r.enhanced_speed :
              (r.speed != null && r.speed > 0 ? r.speed : NaN);
    if(!isFinite(spd) && i>0 && isFinite(elapsed - xs[i-1]) && isFinite(dist_km) && isFinite(series.distance[i-1])){
      const dd = dist_km - series.distance[i-1];
      const dt = elapsed - xs[i-1];
      const v = (dd>0 && dt>0) ? (dd*1000)/dt : NaN;
      spd = v;
    }
    const pace_min_per_km = (spd && spd>0) ? (1000/spd)/60 : NaN;
    const cadence_spm = (r.cadence != null) ? r.cadence * 2 : NaN;
    const hsi = (hsiKey && r.dev[hsiKey]) ? r.dev[hsiKey].value : NaN;
    const elev = (r.enhanced_altitude != null) ? r.enhanced_altitude :
                 (r.altitude != null ? r.altitude : NaN);

    let lat=NaN, lon=NaN;
    if(r.position_lat != null && r.position_long != null){
      lat = semicirclesToDeg(r.position_lat);
      lon = semicirclesToDeg(r.position_long);
      hasLatLon = true;
    }

    series.core.push(core); series.skin.push(skin); series.hr.push(hr);
    series.pace.push(pace_min_per_km); series.distance.push(dist_km);
    series.cadence.push(cadence_spm); series.hsi.push(hsi);
    series.elev.push(elev); series.lat.push(lat); series.lon.push(lon);
  }

  state.viewStart = 0;
  state.viewEnd = xs.length ? xs[xs.length-1] : 0;
  state.hasRoute = hasLatLon;
  return { xs, series };
}

function collectDevCandidates(){
  const keys = listAllDevKeys();
  const pick = (cond) => {
    for(const k of keys){
      const n = (devName(k)||'').toLowerCase();
      const u = (devUnits(k)||'').toLowerCase();
      const v = firstDevValue(k);
      if(cond(n,u,v)) return { key:k, scale: guessScale(v) };
    }
    return null;
  };
  const isTemp = (n,u,v)=> (n.includes('core')||n.includes('skin')||u.includes('c')||n.includes('temp')) && isFinite(v);
  const core = pick((n,u,v)=> isTemp(n,u,v) && (n.includes('core') || n.includes('esophageal') || n.includes('rectal')));
  const skin = pick((n,u,v)=> isTemp(n,u,v) && (n.includes('skin') || n.includes('surface') || (!core && n.includes('temp'))));
  return { core, skin };
}
function guessScale(v){
  if(!isFinite(v) || v===0) return 1;
  if(v > 200 && v < 10000) return 0.01;
  if(v > 10000 && v < 1000000) return 0.001;
  return 1;
}
function listAllDevKeys(){
  const set = new Set();
  for(const r of state.records){ for(const k of Object.keys(r.dev)) set.add(k); }
  return Array.from(set);
}
function devName(k){ for(const r of state.records){ if(r.dev[k]) return r.dev[k].name || k; } return k; }
function devUnits(k){ for(const r of state.records){ if(r.dev[k]) return r.dev[k].units || ''; } return ''; }
function firstDevValue(k){ for(const r of state.records){ if(r.dev[k]) return r.dev[k].value; } return NaN; }

function smoothZeroPhase(xs, ys, tauSec){
  if(!ys || ys.length===0) return [];
  if(tauSec <= 0) return ys.slice();
  const n = ys.length;
  const out = new Array(n).fill(NaN);
  const fwd = new Array(n).fill(NaN);
  const bwd = new Array(n).fill(NaN);
  let prev = null, prevX = null;
  for(let i=0;i<n;i++){
    const y = ys[i], x = xs[i];
    if(!isFinite(y)) { fwd[i] = prev; prevX = x; continue; }
    if(prev == null){ prev = y; prevX = x; fwd[i] = y; continue; }
    const dt = Math.max(1e-9, x - prevX);
    const alpha = 1 - Math.exp(-dt / tauSec);
    prev = prev + alpha*(y - prev);
    prevX = x; fwd[i] = prev;
  }
  prev = null; prevX = null;
  for(let i=n-1;i>=0;i--){
    const y = ys[i], x = xs[i];
    if(!isFinite(y)) { bwd[i] = prev; prevX = x; continue; }
    if(prev == null){ prev = y; prevX = x; bwd[i] = y; continue; }
    const dt = Math.max(1e-9, (prevX - x));
    const alpha = 1 - Math.exp(-dt / tauSec);
    prev = prev + alpha*(y - prev);
    prevX = x; bwd[i] = prev;
  }
  for(let i=0;i<n;i++){
    const a=fwd[i], c=bwd[i];
    out[i] = (isFinite(a) && isFinite(c)) ? 0.5*(a+c) : (isFinite(a)?a : (isFinite(c)?c : NaN));
  }
  return out;
}
function downsample(xs, ys, maxPoints){
  const n = xs.length;
  if(n === 0) return { xs:[], ys:[] };
  if(n <= maxPoints) return { xs: xs.slice(), ys: ys.slice() };
  const stride = Math.max(1, Math.ceil(n / maxPoints));
  const xs2 = [], ys2 = [];
  for(let i=0;i<n;i+=stride){ xs2.push(xs[i]); ys2.push(ys[i]); }
  return { xs: xs2, ys: ys2 };
}
function fmtPace(minPerKm){
  if(!isFinite(minPerKm) || minPerKm <= 0 || minPerKm > 30) return '—';
  const m = Math.floor(minPerKm);
  const s = Math.round((minPerKm - m) * 60);
  const s2 = s === 60 ? 0 : s;
  const m2 = s === 60 ? m+1 : m;
  return `${m2}:${String(s2).padStart(2,'0')} /km`;
}
function fmtNum(v, digits=1){ return isFinite(v) ? v.toFixed(digits) : '—'; }
function fmtTime(sec){
  if(!isFinite(sec) || sec<0) return '—';
  const h = Math.floor(sec/3600); const m = Math.floor((sec%3600)/60); const s = Math.floor(sec%60);
  return h>0 ? `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}` : `${m}:${String(s).padStart(2,'0')}`;
}

const chart = { el:null, ctx:null, width:0, height:0, plot:{x:0,y:0,w:0,h:0}, xs:[], series:null, smoothed:{}, yLeft:[0,1], yRight:[0,1], hover:null };

function initCanvas(canvas){
  const rect = canvas.getBoundingClientRect();
  const ratio = dpr();
  canvas.width = Math.max(10, Math.floor(rect.width * ratio));
  canvas.height = Math.max(10, Math.floor(rect.height * ratio));
  const ctx = canvas.getContext('2d');
  ctx.setTransform(ratio,0,0,ratio,0,0);
  return ctx;
}
function resizeAll(){
  if(chart.el){ chart.ctx = initCanvas(chart.el); }
  routeCanvasResize();
  draw();
  drawRoute();
}
function setMessage(text){ const m = document.getElementById('message'); if(m) m.textContent = text || ''; }

function updateMaxima(){
  const el = document.getElementById('maxima');
  if(!chart.xs.length || !chart.smoothed.core){ el.textContent = ''; return; }
  const [x0,x1] = visibleRange();
  const idx0 = findIndexAtTime(x0);
  const idx1 = Math.min(findIndexAtTime(x1), chart.xs.length-1);
  function maxIn(arr){ if(!arr || !arr.length) return NaN; let m=-Infinity; for(let i=idx0;i<=idx1;i++){ const v=arr[i]; if(isFinite(v) && v>m) m=v; } return m===-Infinity?NaN:m; }
  const rows=[];
  if(state.show.core) rows.push(`Max Core: ${fmtNum(maxIn(chart.smoothed.core),1)} °C`);
  if(state.show.skin) rows.push(`Max Skin: ${fmtNum(maxIn(chart.smoothed.skin),1)} °C`);
  if(state.show.hr) rows.push(`Max HR: ${fmtNum(maxIn(chart.smoothed.hr),0)} bpm`);
  rows.push(`Window: ${fmtTime(x1-x0)}`);
  if(state.show.hsi) rows.push(`Max HSI: ${fmtNum(maxIn(chart.smoothed.hsi),2)}`);
  if(state.show.distance) rows.push(`Max Dist: ${fmtNum(maxIn(chart.smoothed.distance),2)} km`);
  if(state.show.pace) rows.push(`Max Pace: ${fmtPace(maxIn(chart.smoothed.pace))}`);
  if(state.show.cadence) rows.push(`Max Cadence: ${fmtNum(maxIn(chart.smoothed.cadence),0)} spm`);
  el.textContent = rows.join('   •   ');
}
function layoutPlot(){
  const padL = 48, padR = 48, padT = 8, padB = 22;
  const rect = chart.el.getBoundingClientRect();
  chart.width = rect.width; chart.height = rect.height;
  chart.plot = { x: padL, y: padT, w: Math.max(10, chart.width - padL - padR), h: Math.max(10, chart.height - padT - padB) };
}
function visibleRange(){ return [state.viewStart, state.viewEnd]; }
function findIndexAtTime(t){
  const xs = chart.xs; if(!xs.length) return 0;
  let lo=0, hi=xs.length-1;
  while(lo<hi){ const mid=(lo+hi)>>>1; if(xs[mid] < t) lo=mid+1; else hi=mid; }
  return lo;
}
function calcYAxisDomains(){
  if(!chart.xs.length){ chart.yLeft=[0,1]; chart.yRight=[0,1]; return; }
  const [x0,x1]=visibleRange(); const i0=findIndexAtTime(x0); const i1=Math.min(findIndexAtTime(x1), chart.xs.length-1);
  let minL=+Infinity, maxL=-Infinity;
  const add=(arr)=>{ if(!arr) return; for(let i=i0;i<=i1;i++){ const v=arr[i]; if(!isFinite(v)) continue; if(v<minL) minL=v; if(v>maxL) maxL=v; } };
  if(state.show.core) add(chart.smoothed.core);
  if(state.show.skin) add(chart.smoothed.skin);
  if(!isFinite(minL) || !isFinite(maxL)){ minL=0; maxL=1; }
  minL = Math.floor(minL); const maxLPadded = maxL + (maxL - minL) * 0.05;

  let minR=+Infinity, maxR=-Infinity;
  const addR=(arr)=>{ if(!arr) return; for(let i=i0;i<=i1;i++){ const v=arr[i]; if(!isFinite(v)) continue; if(v<minR) minR=v; if(v>maxR) maxR=v; } };
  if(state.show.hr) addR(chart.smoothed.hr);
  if(state.show.distance) addR(chart.smoothed.distance);
  if(state.show.pace) addR(chart.smoothed.pace);
  if(state.show.cadence) addR(chart.smoothed.cadence);
  if(state.show.hsi) addR(chart.smoothed.hsi);
  if(!isFinite(minR) || !isFinite(maxR)){ minR=0; maxR=1; }
  const maxRPadded = maxR + (maxR - minR) * 0.05;

  chart.yLeft=[minL, maxLPadded]; chart.yRight=[minR, maxRPadded];
}
function xToPx(x){ const [x0,x1]=visibleRange(); const {x:lx,w}=chart.plot; if(x1===x0) return lx; return lx + ((x-x0)/(x1-x0))*w; }
function yToPxL(y){ const {y:ty,h}=chart.plot; const [y0,y1]=chart.yLeft; if(y1===y0) return ty+h/2; return ty + (1 - (y - y0)/(y1 - y0)) * h; }
function yToPxR(y){ const {y:ty,h}=chart.plot; const [y0,y1]=chart.yRight; if(y1===y0) return ty+h/2; return ty + (1 - (y - y0)/(y1 - y0)) * h; }

function drawAxes(){
  const ctx = chart.ctx; const {x,y,w,h}=chart.plot;
  ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1; ctx.strokeRect(x,y,w,h);
  const ticks=5;
  for(let i=0;i<=ticks;i++){
    const yy=y+(i/ticks)*h; ctx.beginPath(); ctx.moveTo(x,yy); ctx.lineTo(x+w,yy);
    ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.stroke();
  }
  ctx.fillStyle='#c9d4e5'; ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.textAlign='right'; ctx.textBaseline='middle';
  const [l0,l1]=chart.yLeft, [r0,r1]=chart.yRight;
  for(let i=0;i<=ticks;i++){
    const p=i/ticks; const yy=y+p*h; const ly=l1 - p*(l1-l0); const ry=r1 - p*(r1-r0);
    if(state.show.core || state.show.skin){ ctx.fillStyle='#c9d4e5'; ctx.fillText(ly.toFixed(0), x-6, yy); }
    ctx.fillStyle='#9fb0c9'; ctx.textAlign='left'; ctx.fillText(ry.toFixed(0), x+w+6, yy); ctx.textAlign='right';
  }
  ctx.textAlign='center'; ctx.textBaseline='top';
  const [x0,x1]=visibleRange();
  for(let i=0;i<=ticks;i++){
    const xx=x+(i/ticks)*w; const tt=x0+(i/ticks)*(x1-x0); ctx.fillStyle='#b9c6db'; ctx.fillText(fmtTime(tt), xx, y+h+4);
  }
  ctx.restore();
}

function drawHSIBackground(){
  if(!state.showHSIbg || !chart.xs.length) return;
  const hsi = chart.smoothed.hsi || []; if(!hsi.length) return;
  const ctx = chart.ctx; const {x,y,w,h}=chart.plot;
  ctx.save(); ctx.beginPath(); ctx.rect(x,y,w,h); ctx.clip();
  const target = Math.max(50, Math.floor(w/2));
  const { xs:dxs, ys:dys } = downsample(chart.xs, hsi, target);
  const styles = getComputedStyle(document.documentElement);
  const green = styles.getPropertyValue('--hsi-green').trim() || '#e6f5ea';
  const orange = styles.getPropertyValue('--hsi-orange').trim() || '#fff1e0';
  const red = styles.getPropertyValue('--hsi-red').trim() || '#ffe7e7';
  const colorFor = (v)=> !isFinite(v) ? null : (v<1 ? green : (v<2 ? orange : red));
  for(let i=0;i<dxs.length-1;i++){
    const x0 = xToPx(dxs[i]); const x1 = xToPx(dxs[i+1]);
    const c = colorFor(dys[i]); if(!c) continue;
    ctx.fillStyle = c; ctx.fillRect(x0, y, Math.max(1, x1-x0+1), h);
  }
  ctx.restore();
}

function drawElevationBackdrop(){
  if(!state.showElevBG || !chart.xs.length) return;
  const elev = chart.smoothed.elev || []; if(!elev.length) return;
  const [x0,x1] = visibleRange(); const i0=findIndexAtTime(x0); const i1=Math.min(findIndexAtTime(x1), chart.xs.length-1);
  let min=+Infinity,max=-Infinity; for(let i=i0;i<=i1;i++){ const v=elev[i]; if(!isFinite(v)) continue; if(v<min) min=v; if(v>max) max=v; }
  if(!isFinite(min) || !isFinite(max) || max-min < 1e-9) return;
  const ctx = chart.ctx; const {x,y,w,h}=chart.plot; ctx.save(); ctx.beginPath(); ctx.rect(x,y,w,h); ctx.clip();
  const target = Math.max(100, Math.floor(w/1.5));
  const { xs:dxs, ys:dys } = downsample(chart.xs, elev, target);
  const yMap = (ev)=> y + (1 - (ev - min)/(max - min)) * h;
  let started=false; ctx.beginPath();
  for(let i=0;i<dxs.length;i++){
    const xv = dxs[i]; const yv = dys[i]; if(!isFinite(yv)) continue;
    const xx=xToPx(xv), yy=yMap(yv);
    if(!started){ ctx.moveTo(xx,yy); started=true; } else { ctx.lineTo(xx,yy); }
  }
  if(started){
    const styles = getComputedStyle(document.documentElement);
    ctx.lineJoin='round'; ctx.lineCap='round';
    // Fill to bottom
    ctx.lineTo(xToPx(dxs[dxs.length-1]), y+h);
    ctx.lineTo(xToPx(dxs[0]), y+h);
    ctx.closePath();
    ctx.fillStyle = styles.getPropertyValue('--elev-fill').trim() || 'rgba(60,60,60,0.08)';
    ctx.fill();
    // Stroke
    ctx.beginPath(); started=false;
    for(let i=0;i<dxs.length;i++){
      const xv=dxs[i], yv=dys[i]; if(!isFinite(yv)) continue;
      const xx=xToPx(xv), yy=yMap(yv);
      if(!started){ ctx.moveTo(xx,yy); started=true; } else { ctx.lineTo(xx,yy); }
    }
    ctx.strokeStyle = styles.getPropertyValue('--elev-stroke').trim() || 'rgba(60,60,60,0.25)';
    ctx.lineWidth = 1.25; ctx.stroke();
  }
  ctx.restore();
}

function drawSeries(){
  if(!chart.xs.length) return;
  const ctx = chart.ctx; const {x,y,w,h}=chart.plot;
  ctx.save(); ctx.beginPath(); ctx.rect(x,y,w,h); ctx.clip();
  const drawLine=(xs,ys,color,yMap)=>{
    if(!xs || !ys || xs.length===0 || ys.length===0) return;
    ctx.beginPath(); let started=false;
    for(let i=0;i<xs.length;i++){
      const v = ys[i]; if(!isFinite(v)) { started=false; continue; }
      const xx=xToPx(xs[i]); const yy=yMap(v);
      if(!started){ ctx.moveTo(xx,yy); started=true; } else { ctx.lineTo(xx,yy); }
    }
    ctx.strokeStyle=color; ctx.lineWidth=1.5; ctx.lineJoin='round'; ctx.lineCap='round'; ctx.stroke();
  };
  if(state.show.core) drawLine(chart.xs, chart.smoothed.core, COLORS.core, yToPxL);
  if(state.show.skin) drawLine(chart.xs, chart.smoothed.skin, COLORS.skin, yToPxL);
  if(state.show.hr) drawLine(chart.xs, chart.smoothed.hr, COLORS.hr, yToPxR);
  if(state.show.distance) drawLine(chart.xs, chart.smoothed.distance, COLORS.distance, yToPxR);
  if(state.show.pace) drawLine(chart.xs, chart.smoothed.pace, COLORS.pace, yToPxR);
  if(state.show.cadence) drawLine(chart.xs, chart.smoothed.cadence, COLORS.cadence, yToPxR);
  if(state.show.hsi) drawLine(chart.xs, chart.smoothed.hsi, COLORS.hsi, yToPxR);
  ctx.restore();
}

function drawCrosshair(){
  if(!chart.hover || !chart.xs.length) return;
  const {x,y,w,h}=chart.plot; const ctx=chart.ctx; const xPx=chart.hover.xPx;
  ctx.save(); ctx.beginPath(); ctx.rect(x,y,w,h); ctx.clip();
  ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(xPx,y); ctx.lineTo(xPx,y+h); ctx.stroke(); ctx.restore();
  drawTooltip(chart.hover.idx, xPx);
}

function drawTooltip(idx, xPx){
  const xs = chart.xs; if(!xs || !xs.length) return;
  idx = clamp(idx, 0, xs.length-1);
  const ctx = chart.ctx; const pad=8;
  const lines = [];
  const t = xs[idx];
  lines.push(`t = ${fmtTime(t)}`);

  const add=(name, show, arr, fmt, color)=>{
    if(!show || !arr || idx >= arr.length) return;
    const v = arr[idx];
    if(!isFinite(v)) return;
    lines.push({ label:name, val: fmt(v), color });
  };
  add('Core', state.show.core, chart.smoothed.core, v=>`${v.toFixed(2)} °C`, COLORS.core);
  add('Skin', state.show.skin, chart.smoothed.skin, v=>`${v.toFixed(2)} °C`, COLORS.skin);
  add('HR', state.show.hr, chart.smoothed.hr, v=>`${v.toFixed(0)} bpm`, COLORS.hr);
  add('HSI', state.show.hsi, chart.smoothed.hsi, v=>v.toFixed(2), COLORS.hsi);
  add('Distance', state.show.distance, chart.smoothed.distance, v=>`${v.toFixed(2)} km`, COLORS.distance);
  add('Pace', state.show.pace, chart.smoothed.pace, v=>fmtPace(v), COLORS.pace);
  add('Cadence', state.show.cadence, chart.smoothed.cadence, v=>`${v.toFixed(0)} spm`, COLORS.cadence);

  ctx.save(); ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  let w=0,h=0;
  const timeText = typeof lines[0] === 'string' ? lines[0] : '';
  w = Math.max(w, ctx.measureText(timeText).width); h += 16;
  const content=[];
  for(let i=1;i<lines.length;i++){ const L=lines[i]; const str=`${L.label}: ${L.val}`; w=Math.max(w, ctx.measureText(str).width); h+=16; content.push(L); }
  w += pad*2 + (content.length?12:0); h += pad*2;
  const {x:lx,y:ty,w:pw} = chart.plot;
  let left = xPx + 10; if(left + w > lx + pw) left = xPx - w - 10; let top = ty + 10;
  ctx.fillStyle='rgba(5,8,14,0.9)'; ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.roundRect(left, top, w, h, 6); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#cfe1ff'; ctx.fillText(timeText, left+pad, top+pad+11);
  let yy=top+pad+24;
  for(const L of content){
    ctx.fillStyle=L.color; ctx.fillRect(left+pad, yy-8, 10, 10);
    ctx.fillStyle='#e7ecf3'; ctx.fillText(`${L.label}: ${L.val}`, left+pad+14, yy);
    yy+=16;
  }
  ctx.restore();
}

function drawSelection(){
  if(!state.selecting) return;
  const ctx = chart.ctx; const {x,y,h}=chart.plot;
  const x0=Math.min(state.selecting.x0, state.selecting.x1);
  const x1=Math.max(state.selecting.x0, state.selecting.x1);
  const xx0=clamp(x0, x, x+chart.plot.w), xx1=clamp(x1, x, x+chart.plot.w);
  ctx.save(); ctx.fillStyle='rgba(25, 118, 210, 0.20)'; ctx.fillRect(xx0,y,Math.max(0,xx1-xx0),h);
  ctx.strokeStyle='rgba(25,118,210,0.65)'; ctx.lineWidth=1; ctx.strokeRect(xx0,y,Math.max(0,xx1-xx0),h); ctx.restore();
}

function draw(){
  if(!chart.ctx) return;
  layoutPlot();
  chart.ctx.clearRect(0,0,chart.width,chart.height);
  drawHSIBackground();
  drawElevationBackdrop();
  drawAxes();
  drawSeries();
  drawCrosshair();
  drawSelection();
}

/* Interactions */
function canvasToTime(px){
  const { x, w } = chart.plot; const [t0,t1] = visibleRange();
  const u = clamp((px - x)/w, 0, 1); return t0 + u*(t1 - t0);
}
function timeToIndex(t){ return clamp(findIndexAtTime(t), 0, Math.max(0, chart.xs.length-1)); }
function pointerDown(ev){
  if(!chart.xs.length) return;
  const rect = chart.el.getBoundingClientRect();
  const cx = ('clientX' in ev ? ev.clientX : (ev.touches?.[0]?.clientX || 0)) - rect.left;
  chart.el.setPointerCapture?.(ev.pointerId || 1);
  if(state.zoomActive){ state.selecting = { x0: cx, x1: cx }; }
  else { chart.hover = { xPx: cx, idx: timeToIndex(canvasToTime(cx)) }; }
  ev.preventDefault(); draw();
}
function pointerMove(ev){
  if(!chart.xs.length) return;
  const rect = chart.el.getBoundingClientRect();
  const cx = ('clientX' in ev ? ev.clientX : (ev.touches?.[0]?.clientX || 0)) - rect.left;
  if(state.zoomActive && state.selecting){ state.selecting.x1 = cx; }
  else { chart.hover = { xPx: cx, idx: timeToIndex(canvasToTime(cx)) }; }
  ev.preventDefault(); draw();
}
function pointerUp(ev){
  if(state.zoomActive && state.selecting && chart.xs.length){
    const { x0, x1 } = state.selecting; state.selecting = null;
    const a = canvasToTime(x0), b = canvasToTime(x1);
    const t0 = Math.min(a,b), t1 = Math.max(a,b);
    if(isFinite(t0) && isFinite(t1) && t1 - t0 > 1){
      state.viewStart = t0; state.viewEnd = t1;
      document.getElementById('clearZoom').disabled = false;
      updateMaxima(); draw(); return;
    }
  }
  ev.preventDefault(); draw();
}

/* Route canvas */
const route = { el:null, ctx:null, width:0, height:0 };
function routeCanvasResize(){
  if(!route.el) return;
  const rect = route.el.getBoundingClientRect(); const ratio = dpr();
  route.el.width = Math.max(10, Math.floor(rect.width * ratio));
  route.el.height = Math.max(10, Math.floor(rect.height * ratio));
  route.ctx = route.el.getContext('2d'); route.ctx.setTransform(ratio,0,0,ratio,0,0);
}
function drawRoute(){
  const section = document.getElementById('routeSection');
  if(section.classList.contains('hidden')) return;
  if(!route.el || !route.ctx) return;
  const lat = (chart.series && chart.series.lat) ? chart.series.lat : [];
  const lon = (chart.series && chart.series.lon) ? chart.series.lon : [];
  const pts = [];
  for(let i=0;i<lat.length;i++){ if(isFinite(lat[i]) && isFinite(lon[i])) pts.push([lat[i], lon[i]]); }
  const ctx = route.ctx;
  const w = route.el.getBoundingClientRect().width;
  const h = route.el.getBoundingClientRect().height;
  ctx.clearRect(0,0,w,h);
  if(pts.length < 2) return;

  let minLat=+Infinity, maxLat=-Infinity, minLon=+Infinity, maxLon=-Infinity;
  for(const [la,lo] of pts){ if(la<minLat) minLat=la; if(la>maxLat) maxLat=la; if(lo<minLon) minLon=lo; if(lo>maxLon) maxLon=lo; }
  const padLat = (maxLat - minLat) * 0.05 || 0.001;
  const padLon = (maxLon - minLon) * 0.05 || 0.001;
  minLat -= padLat; maxLat += padLat; minLon -= padLon; maxLon += padLon;

  const denomLat = (maxLat - minLat) || 1e-9;
  const denomLon = (maxLon - minLon) || 1e-9;

  function project(lat, lon){
    const x = (lon - minLon) / denomLon * (w - 20) + 10;
    const y = (1 - (lat - minLat) / denomLat) * (h - 20) + 10;
    return [x, y];
  }

  ctx.save();
  ctx.fillStyle = '#0c0f14'; ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1;
  ctx.fillRect(0,0,w,h); ctx.strokeRect(0,0,w,h);

  ctx.beginPath(); let started=false;
  for(const [la,lo] of pts){
    const [x,y] = project(la,lo);
    if(!started){ ctx.moveTo(x,y); started=true; } else { ctx.lineTo(x,y); }
  }
  const styles = getComputedStyle(document.documentElement);
  ctx.strokeStyle = styles.getPropertyValue('--accent').trim() || '#1976d2';
  ctx.lineWidth = 3; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.stroke();

  const [sx,sy] = project(pts[0][0], pts[0][1]);
  const [ex,ey] = project(pts[pts.length-1][0], pts[pts.length-1][1]);
  ctx.fillStyle = styles.getPropertyValue('--accent-2').trim() || '#2e7d32';
  ctx.beginPath(); ctx.arc(sx, sy, 5, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = styles.getPropertyValue('--danger').trim() || '#d32f2f';
  ctx.beginPath(); ctx.arc(ex, ey, 5, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* UI */
function populateLegend(){
  const legend = document.getElementById('legend'); if(!legend) return;
  legend.innerHTML = '';
  const items = [
    { key:'core', label:'Core', color:COLORS.core },
    { key:'skin', label:'Skin', color:COLORS.skin },
    { key:'hr', label:'HR', color:COLORS.hr },
    { key:'hsi', label:'HSI', color:COLORS.hsi },
    { key:'distance', label:'Distance', color:COLORS.distance },
    { key:'pace', label:'Pace', color:COLORS.pace },
    { key:'cadence', label:'Cadence', color:COLORS.cadence }
  ];
  for(const it of items){
    const btn = document.createElement('button');
    btn.className = 'chip' + (state.show[it.key] ? ' active' : '');
    btn.innerHTML = `<span class="swatch" style="background:${it.color}"></span>${it.label}`;
    btn.onclick = ()=>{
      state.show[it.key] = !state.show[it.key];
      btn.classList.toggle('active', state.show[it.key]);
      recalcSmooth(); calcYAxisDomains(); updateMaxima(); draw();
    };
    legend.appendChild(btn);
  }
}
function recalcSmooth(){
  const xs = chart.xs || []; const s = chart.series || { core:[],skin:[],hr:[],distance:[],pace:[],cadence:[],hsi:[],elev:[] };
  const T = Math.max(0, state.smoothingSec);
  chart.smoothed.core = smoothZeroPhase(xs, s.core, T);
  chart.smoothed.skin = smoothZeroPhase(xs, s.skin, T);
  chart.smoothed.hr = smoothZeroPhase(xs, s.hr, T);
  chart.smoothed.distance = smoothZeroPhase(xs, s.distance, T);
  chart.smoothed.pace = smoothZeroPhase(xs, s.pace, T);
  chart.smoothed.cadence = smoothZeroPhase(xs, s.cadence, T);
  chart.smoothed.hsi = smoothZeroPhase(xs, s.hsi, T);
  chart.smoothed.elev = smoothZeroPhase(xs, s.elev, T);
}
function openMapModal(devList){
  const backdrop = document.getElementById('modalBackdrop');
  const coreField = document.getElementById('coreField');
  const skinField = document.getElementById('skinField');
  const coreScale = document.getElementById('coreScale');
  const skinScale = document.getElementById('skinScale');
  function fill(select, selected){
    select.innerHTML = '<option value="">—</option>';
    for(const d of devList){
      const opt = document.createElement('option');
      const label = `${d.name || d.key}${d.units ? ' ('+d.units+')' : ''}`;
      opt.value = d.key; opt.textContent = label; if(selected && selected === d.key) opt.selected = true;
      select.appendChild(opt);
    }
  }
  fill(coreField, state.map.coreKey);
  fill(skinField, state.map.skinKey);
  coreScale.value = state.map.coreScale ?? 1;
  skinScale.value = state.map.skinScale ?? 1;
  backdrop.style.display = 'flex';
  document.getElementById('cancelMap').onclick = ()=>{ backdrop.style.display = 'none'; };
  document.getElementById('applyMap').onclick = ()=>{
    state.map.coreKey = coreField.value || null;
    state.map.skinKey = skinField.value || null;
    state.map.coreScale = parseFloat(coreScale.value || '1') || 1;
    state.map.skinScale = parseFloat(skinScale.value || '1') || 1;
    backdrop.style.display = 'none';
    const prepared = prepareData();
    chart.xs = prepared.xs; chart.series = prepared.series;
    recalcSmooth(); calcYAxisDomains(); updateMaxima(); draw();
  };
}

async function handleFile(file){
  try{
    const buf = await file.arrayBuffer();
    const { records, devFieldsList, deviceLine } = await parseFIT(buf);
    if(!records || records.length === 0){ setMessage('No record messages found in this FIT file.'); return; }
    state.records = records; state.fileName = file.name;
    document.getElementById('deviceLine').textContent = deviceLine || 'Device unknown';

    const prepared = prepareData();
    chart.xs = prepared.xs || []; chart.series = prepared.series || {};

    const hasHSI = (chart.series.hsi || []).some(v=>isFinite(v));
    const hasElev = (chart.series.elev || []).some(v=>isFinite(v));
    state.showHSIbg = hasHSI; state.showElevBG = hasElev;
    const hsiBtn = document.getElementById('toggleHSIbg'); const elevBtn = document.getElementById('toggleElevBG');
    hsiBtn.classList.toggle('hidden', !hasHSI); elevBtn.classList.toggle('hidden', !hasElev);
    hsiBtn.classList.toggle('active', state.showHSIbg); elevBtn.classList.toggle('active', state.showElevBG);

    const hasRoute = state.hasRoute && (chart.series.lat||[]).some(isFinite) && (chart.series.lon||[]).some(isFinite);
    document.getElementById('routeSection').classList.toggle('hidden', !hasRoute);

    const mapBtn = document.getElementById('mapFieldsBtn');
    mapBtn.disabled = !(devFieldsList && devFieldsList.length);
    mapBtn.onclick = ()=> openMapModal(devFieldsList||[]);

    recalcSmooth(); calcYAxisDomains(); populateLegend(); updateMaxima(); draw(); drawRoute();
    setMessage('Slide finger to inspect values. Toggle Zoom to select a time range and tap Clear Zoom to reset.');
  } catch(err){
    console.error(err); setMessage('Failed to parse FIT file. See console for details.');
  }
}

/* Init */
window.addEventListener('DOMContentLoaded', ()=>{
  chart.el = document.getElementById('chart'); chart.ctx = initCanvas(chart.el);
  route.el = document.getElementById('routeCanvas'); route.ctx = initCanvas(route.el);

  chart.el.addEventListener('pointerdown', pointerDown, {passive:false});
  chart.el.addEventListener('pointermove', pointerMove, {passive:false});
  chart.el.addEventListener('pointerup', pointerUp, {passive:false});
  chart.el.addEventListener('pointercancel', pointerUp, {passive:false});
  chart.el.addEventListener('pointerleave', pointerUp, {passive:false});

  document.querySelector('.file .btn').onclick = ()=> document.getElementById('fileInput').click();
  document.getElementById('fileInput').addEventListener('change', (e)=>{ const f = e.target.files?.[0]; if(f) handleFile(f); });

  document.getElementById('resetBtn').onclick = ()=>{
    state.fileName=null; state.records=[]; state.t0=null; state.viewStart=0; state.viewEnd=0; state.zoomActive=false; state.selecting=null;
    chart.xs=[]; chart.series=null; chart.smoothed={}; chart.hover=null;
    document.getElementById('zoomToggle').textContent='Zoom: OFF';
    document.getElementById('clearZoom').disabled=true;
    document.getElementById('deviceLine').textContent='No file loaded';
    document.getElementById('routeSection').classList.add('hidden');
    document.getElementById('mapFieldsBtn').disabled=true;
    document.getElementById('toggleHSIbg').classList.add('hidden');
    document.getElementById('toggleElevBG').classList.add('hidden');
    populateLegend(); updateMaxima(); draw(); drawRoute();
    setMessage('Load a .fit file to view data.');
  };

  document.getElementById('zoomToggle').onclick = ()=>{
    state.zoomActive = !state.zoomActive;
    document.getElementById('zoomToggle').textContent = `Zoom: ${state.zoomActive ? 'ON' : 'OFF'}`;
  };
  document.getElementById('clearZoom').onclick = ()=>{
    state.viewStart = 0; state.viewEnd = chart.xs.length ? chart.xs[chart.xs.length-1] : 0;
    document.getElementById('clearZoom').disabled = true; updateMaxima(); draw();
  };

  const sr = document.getElementById('smoothRange'); const sv = document.getElementById('smoothVal');
  sr.addEventListener('input', ()=>{
    state.smoothingSec = parseInt(sr.value,10)||0; sv.textContent = `${state.smoothingSec} s`;
    if(chart.series){ recalcSmooth(); calcYAxisDomains(); updateMaxima(); draw(); }
  }); sv.textContent = `${state.smoothingSec} s`;

  const hsiBtn = document.getElementById('toggleHSIbg');
  const elevBtn = document.getElementById('toggleElevBG');
  hsiBtn.onclick = ()=>{ state.showHSIbg = !state.showHSIbg; hsiBtn.classList.toggle('active', state.showHSIbg); draw(); };
  elevBtn.onclick = ()=>{ state.showElevBG = !state.showElevBG; elevBtn.classList.toggle('active', state.showElevBG); draw(); };

  window.addEventListener('resize', resizeAll);

  populateLegend(); draw(); drawRoute();
});

if(!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    r=Math.min(r, w/2, h/2);
    this.beginPath(); this.moveTo(x+r, y);
    this.arcTo(x+w, y, x+w, y+h, r);
    this.arcTo(x+w, y+h, x, y+h, r);
    this.arcTo(x, y+h, x, y, r);
    this.arcTo(x, y, x+w, y, r);
    this.closePath(); return this;
  };
}
</script>
</body>
</html>