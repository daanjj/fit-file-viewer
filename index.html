<!doctype html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-GR1R0S0C8M"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    
    gtag('config', 'G-GR1R0S0C8M');
  </script>
  <meta charset="utf-8" />
  <title>FIT Viewer -- view core/skin temperatures and other stats (BETA v0.5.7 for ThermoClinics)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    /* Leaflet map styles */
    .leaflet-container{background:#ffffff}
    #map{display:block;width:100%;height:40vh;border-radius:10px;overflow:hidden}

    :root{
      --bg:#0f1216;
      --panel:#171b21;
      --text:#e5e9f0;
      --muted:#9aa4b2;
      --accent:#4fc3f7;
      --hr:#e53935;
      --core:#1e88e5;
      --skin:#fb8c00;
      --grid:#232a32;
      --ok:#2e7d32;
      --warn:#ef6c00;
      --err:#e53935;

      --hsi:#ab47bc;
      --dist:#66bb6a;
      --pace:#26c6da;
      --speed:#ff7043;
      --cad:#ffd54f;
      --power:#9c27b0;
      --select:#4fc3f733;
      --select-border:#4fc3f7aa;

      /* HSI zones on white canvas */
      --hsi-bg-green:#2e7d322a;
      --hsi-bg-orange:#e09f0f2a;
      --hsi-bg-red-med:#e539352a;
      --hsi-bg-red-dark:#b91c1c2a;

      /* Elevation background */
      --elev-stroke:#6b728066;
      --elev-fill:#6b728029;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
      font:400 16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Apple Color Emoji,Segoe UI Emoji}
    a{color:var(--accent);text-decoration:none}

    header{
      padding:12px 14px;
      background:var(--panel);
      border-bottom:1px solid #20262e;
    }
    header .title{font-weight:700;font-size:16px;margin-bottom:6px}
    .section-heading{
      font-weight:700;font-size:12px;letter-spacing:.04em;color:var(--muted);
      text-transform:uppercase;margin:6px 0 2px 0;
    }
    .device-line{
      color:var(--text);
      font-size:13px;
      margin:2px 0 8px 0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    input[type="file"]{
      color:var(--text);
      background:#10141a;
      border:1px solid #2a313b;
      padding:8px 10px;border-radius:10px;
      width:100%;
      max-width:420px;
    }
    .btn{
      background:#243041;border:1px solid #334255;color:var(--text);
      padding:8px 12px;border-radius:10px;cursor:pointer;
    }
    .btn:disabled{opacity:0.6;cursor:not-allowed}

    .legend{
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start; /* New: Centers the items */
      gap: 10px;
      margin-top: 8px;
    }
    .chip{
      display:flex;align-items:center;gap:8px;
      background:#11161d;border:1px solid #2a313b;border-radius:999px;padding:6px 10px;cursor:pointer;
      user-select:none;
      max-width: 150px; /* New: Constrains the maximum width of each chip */
    }
    .swatch{width:14px;height:14px;border-radius:50%}
    .chip input{display:none}
    .chip input:checked ~ .label{opacity:1}
    .chip .label{opacity:0.95}
    .chip .unit{color:var(--muted);margin-left:4px}
    .chip .state{color:var(--muted);margin-left:8px;font-weight:600}
    /* Legend: hide textual On/Off and grey out when off */
    .legend .chip .state{display:none}
    .legend .chip input:not(:checked) ~ .label{opacity:0.55}
    .legend .chip input:not(:checked) ~ .swatch{filter:grayscale(60%) brightness(75%);opacity:0.6}

    .sticky-bar{
      position:sticky;top:0;z-index:50;
      padding:8px 14px;
      background:var(--panel);
      border-bottom:1px solid #20262e;
      padding-top:calc(8px + env(safe-area-inset-top, 0px));
    }
    .slider-wrap{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .range{
      -webkit-appearance:none;width:min(420px, 100%);height:28px;background:transparent;padding:0;margin:0
    }
    .range:focus{outline:none}
    .range::-webkit-slider-runnable-track{height:6px;background:#2a313b;border-radius:999px;border:0}
    .range::-webkit-slider-thumb{
      -webkit-appearance:none;margin-top:-6px;
      width:18px;height:18px;border-radius:50%;background:#4fc3f7;border:2px solid #1a222b
    }
    .range::-moz-range-track{height:6px;background:#2a313b;border:0;border-radius:999px}
    .range::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:#4fc3f7;border:2px solid #1a222b}

    .stats{display:flex;gap:14px;flex-wrap:wrap;color:var(--muted);font-size:14px;margin-top:6px}
    .kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;
      background:#0f141a;border:1px solid #2a313b;padding:2px 6px;border-radius:6px;color:var(--muted)
    }

    .wrap{padding:10px;display:flex;flex-direction:column;gap:10px}
    .card{background:var(--panel);border:1px solid #20262e;border-radius:12px;padding:10px}
    canvas{
      display:block;width:100%;height:58vh;background:#ffffff;border-radius:10px;
      touch-action:none;
    }
    .msg{font-size:14px;color:var(--muted);margin-top:6px}
    .error{color:var(--err)}
    .ok{color:var(--ok)}
    .warn{color:var(--warn)}
    .footer{color:var(--muted);font-size:12px;text-align:center;padding:16px}

    .modal-backdrop{
      position:fixed;inset:0;background:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center;padding:16px;z-index:100;
    }
    .modal{
      width:100%;max-width:520px;background:var(--panel);border:1px solid #2a313b;border-radius:12px;padding:14px;
      outline:none;
    }
    .modal h3{margin:0 0 8px 0}
    .modal p{color:var(--muted);margin:0 0 12px 0}
    .col{display:flex;flex-direction:column;gap:6px}
    label{font-size:14px;color:var(--muted)}
    select, input[type="number"]{
      background:#0f141a;color:var(--text);border:1px solid #2a313b;border-radius:8px;padding:8px;min-width:140px
    }

    .sel-rect{
      background:var(--select);
      border:1px solid var(--select-border);
    }
  </style>
 <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
 <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
</head>
<body>
  <header>
    <div class="title">FIT Viewer -- view core/skin temperatures and other stats (BETA v0.5.7 for ThermoClinics usage)</div>

    <div class="section-heading" aria-hidden="true">Metadata</div>
    <div id="deviceName" class="device-line" aria-label="Device metadata line"></div>
    <div id="activityTime" class="device-line" aria-label="Activity date and time range"></div>

    <div class="row">
      <button id="androidFsBtn" class="btn" style="display:none">Choose FIT File</button>
      <input id="file" type="file" accept=".fit,.FIT,application/vnd.ant.fit,application/fit" />
      <button id="resetBtn" class="btn" disabled>Reset</button>
      <button id="zoomModeBtn" class="btn" disabled>Zoom: Off</button>
      <button id="zoomClearBtn" class="btn" disabled>Clear Zoom</button>
      <button id="mapBtn" class="btn" disabled style="display:none">Map Fields</button>
    </div>
    <div id="fileHint" class="msg" style="margin-top:4px"></div>

    <div class="legend" id="legend">
      <label class="chip" id="chip-hr"><input type="checkbox" id="toggle-hr" checked><span class="swatch" style="background:var(--hr)"></span><span class="label">Heart Rate</span></label>
      <label class="chip" id="chip-core"><input type="checkbox" id="toggle-core" checked><span class="swatch" style="background:var(--core)"></span><span class="label">Core Temp</span></label>
      <label class="chip" id="chip-skin"><input type="checkbox" id="toggle-skin" checked><span class="swatch" style="background:var(--skin)"></span><span class="label">Skin Temp</span></label>
      <label class="chip" id="chip-hsi"><input type="checkbox" id="toggle-hsi"><span class="swatch" style="background:var(--hsi)"></span><span class="label">Heat Strain Index</span></label>
      <label class="chip" id="chip-dist"><input type="checkbox" id="toggle-dist"><span class="swatch" style="background:var(--dist)"></span><span class="label">Distance</span></label>
      <label class="chip" id="chip-pace"><input type="checkbox" id="toggle-pace"><span class="swatch" style="background:var(--pace)"></span><span class="label">Pace</span></label>
      <label class="chip" id="chip-speed"><input type="checkbox" id="toggle-speed"><span class="swatch" style="background:var(--speed)"></span><span class="label">Speed</span></label>
      <label class="chip" id="chip-power"><input type="checkbox" id="toggle-power"><span class="swatch" style="background:var(--power)"></span><span class="label">Power</span></label>
      <label class="chip" id="chip-cad"><input type="checkbox" id="toggle-cad"><span class="swatch" style="background:var(--cad)"></span><span class="label">Cadence</span></label>
    </div>
  </header>

  <div class="sticky-bar" aria-label="Controls that stay visible">
    <div class="row slider-wrap">
      <span id="smoothText" class="kbd">Smoothing: 0 s</span>
      <input id="smoothSlider" class="range" type="range" min="0" max="100" step="1" value="75" />
    </div>
    <div class="row" style="margin-top:6px">
      <label class="chip"><input type="checkbox" id="toggle-trim" checked><span class="swatch" style="background:#4b5563"></span><span class="label">Trim Early Noise</span><span class="state" id="state-trim">On</span></label>
      <label class="chip"><input type="checkbox" id="toggle-xaxis"><span class="swatch" style="background:#6366f1"></span><span class="label">Time of Day</span><span class="state" id="state-xaxis">Off</span></label>
    </div>
    <div class="stats" id="stats"></div>
  </div>

  <div class="wrap">
    <div class="card">
      <canvas id="chart" aria-label="Graph; slide to inspect, enable Zoom to select a range"></canvas>
      <div id="message" class="msg">Load a .FIT file. Zoom mode is OFF by default so you can slide across the graph to see values. Turn Zoom mode ON to drag-select a time range. All parsing and rendering happens locally.</div>
<div id="missingMsg" class="msg"></div>
    </div>
  </div>

 <div class="wrap">
   <div class="card">
     <div id="map"></div>
     <div id="mapStatus" class="msg" style="margin-top:6px"></div>
   </div>
 </div>

  <div class="footer" id="footerText">
    Privacy: Your file never leaves your device.
  </div>

  <div class="modal-backdrop" id="modalBackdrop" role="dialog" aria-modal="true" aria-labelledby="mapTitle">
    <div class="modal" tabindex="-1">
      <h3 id="mapTitle">Map Developer Fields</h3>
      <p>Select which developer fields represent Core and Skin temperatures. Optionally set a scale (e.g., 0.01 if values are in centi-degrees).</p>
      <div class="row">
        <div class="col" style="flex:1 1 220px">
          <label for="coreSelect">Core Temp Field</label>
          <select id="coreSelect"></select>
        </div>
        <div class="col" style="width:120px">
          <label for="coreScale">Core Scale</label>
          <input id="coreScale" type="number" step="0.0001" value="1" />
        </div>
        <div class="col" style="width:120px">
          <label for="coreOffset">Core Offset</label>
          <input id="coreOffset" type="number" step="0.1" value="0" />
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <div class="col" style="flex:1 1 220px">
          <label for="skinSelect">Skin Temp Field</label>
          <select id="skinSelect"></select>
        </div>
        <div class="col" style="width:120px">
          <label for="skinScale">Skin Scale</label>
          <input id="skinScale" type="number" step="0.0001" value="1" />
        </div>
        <div class="col" style="width:120px">
          <label for="skinOffset">Skin Offset</label>
          <input id="skinOffset" type="number" step="0.1" value="0" />
        </div>
      </div>
      <div class="msg" id="mapHint"></div>
      <div class="row" style="justify-content:flex-end;margin-top:12px">
        <button id="cancelMap" class="btn">Cancel</button>
        <button id="applyMap" class="btn">Apply</button>
      </div>
    </div>
  </div>

  <script>
    const textDecoder = new TextDecoder('utf-8');
    const FIT_EPOCH_OFFSET = 631065600; // Seconds from 1970-01-01 to 1989-12-31

    function clamp(v,min,max){return Math.max(min, Math.min(max, v));}
    function pad2(n){return n<10?'0'+n:''+n;}
    function fmtHMS(sec){
      sec = Math.max(0, Math.floor(sec));
      const h = Math.floor(sec/3600);
      const m = Math.floor((sec%3600)/60);
      const s = sec % 60;
      return (h>0? (h+':') : '') + pad2(m) + ':' + pad2(s);
    }
    function fmtTOD(date) {
      if (!(date instanceof Date) || !isFinite(date)) return '--:--:--';
      return pad2(date.getHours()) + ':' + pad2(date.getMinutes()) + ':' + pad2(date.getSeconds());
    }
    function fmtDate(date) {
      if (!(date instanceof Date) || !isFinite(date)) return 'N/A';
      return date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
    }
    function fmtS(sec){
      if (sec >= 10) return Math.round(sec) + ' s';
      if (sec >= 1) return (Math.round(sec*10)/10).toFixed(1) + ' s';
      return (Math.round(sec*100)/100).toFixed(2) + ' s';
    }
    function fmtPace(minPerKm){
      if (!isFinite(minPerKm) || minPerKm<=0) return '--';
      const totalSec = minPerKm*60;
      const m = Math.floor(totalSec/60);
      const s = Math.round(totalSec % 60);
      return `${m}:${pad2(s)} /km`;
    }
    function niceTicks(min, max, count=5){
      if (!isFinite(min) || !isFinite(max)) return [];
      if (min===max) return [min];
      const span = Math.max(1e-12, max - min);
      const step0 = Math.pow(10, Math.floor(Math.log10(span / count)));
      const err = (span / count) / step0;
      let step;
      if (err >= 7.5) step = 10*step0;
      else if (err >= 3.5) step = 5*step0;
      else if (err >= 1.5) step = 2*step0;
      else step = step0;
      const start = Math.ceil(min/step)*step;
      const ticks = [];
      for (let v=start; v<=max+1e-9; v+=step) ticks.push(v);
      if (ticks.length===0) ticks.push(min);
      return ticks;
    }
    function getVar(name, fallback){
      const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      return v || fallback;
    }

    const MANUFACTURERS = {
      1:'Garmin', 13:'SRAM', 15:'Zwift', 23:'Tacx', 32:'Wahoo', 38:'Stages',
      42:'Suunto', 70:'Hammerhead', 76:'Stages', 89:'Polar', 167:'COROS'
    };

    function normalizeProductName(brand, name){
      if (!name) return name;
      const s = String(name).trim();
      const lc = s.toLowerCase();
      const brandLc = (brand||'').toLowerCase();
      if (brandLc === 'garmin') {
        // Forerunner: 'frXX', 'fr XX', 'forerunnerXX', 'forerunner XX' (+ optional 'Music')
        const music = /music/i.test(s);
        const fr = lc.match(/(?:^|\b)(?:fr|forerunner)\s*(\d{2,3})\b/);
        if (fr && fr[1]) return `Forerunner ${fr[1]}${music ? ' Music' : ''}`;
        // Edge: 'edge 530/830/1030, etc'
        const edge = lc.match(/edge\s*(\d{3,4})\b/);
        if (edge && edge[1]) return `Edge ${edge[1]}`;
        // Venu: 'venu', 'venu 2', 'venu sq'
        const venu2 = lc.match(/venu\s*(sq|2|2s|3|3s)?\b/);
        if (venu2) {
          const tag = venu2[1];
          return `Venu${tag ? ' ' + tag.toUpperCase() : ''}`;
        }
        // Vivoactive
        const va = lc.match(/vivoactive\s*(\d+|hr)?\b/);
        if (va) {
          const tag = va[1];
          return `Vivoactive${tag ? ' ' + String(tag).toUpperCase() : ''}`;
        }
        // Instinct: 'instinct', 'instinct 2/2s'
        const inst = lc.match(/instinct\s*(2s|2)?\b/);
        if (inst) return `Instinct${inst[1] ? ' ' + inst[1].toUpperCase() : ''}`;
        // Fenix (normalize diacritics)
        const fenix = lc.match(/f[eē]nix\s*([0-9xXsS+\spro]+)?/);
        if (fenix) {
          const tag = fenix[1] ? fenix[1].replace(/\s+/g,' ').trim() : '';
          return `Fenix${tag ? ' ' + tag.toUpperCase() : ''}`;
        }
        // Epix
        const epix = lc.match(/epix\s*(gen\s*2|pro)?/);
        if (epix) return `Epix${epix[1] ? ' ' + epix[1].replace(/\s+/g,' ').toUpperCase() : ''}`;
        // MARQ
        if (/\bmarq\b/i.test(s)) return 'MARQ';
        // Descent
        const descent = lc.match(/descent\s*([a-z0-9]+)?/);
        if (descent) return `Descent${descent[1] ? ' ' + descent[1].toUpperCase() : ''}`;
        // D2 (Aviation)
        const d2 = lc.match(/\bd2\s*([a-z0-9]+)?/);
        if (d2) return `D2${d2[1] ? ' ' + d2[1].toUpperCase() : ''}`;
      }
      return s;
    }

    class FitParser {
      constructor() {
        this._devKeysUsed = new Set();
        this.devFieldDescriptions = new Map();
        this.fieldDescObjs = [];
        this.fileIds = [];
        this.deviceInfos = [];
        this.fileCreators = [];
      }

      parse(arrayBuffer) {
        const view = new DataView(arrayBuffer);
        let pos = 0;

        const headerSize = view.getUint8(pos); pos+=1;
        pos+=1; pos+=2;
        const dataSize = view.getUint32(pos, true); pos+=4;
        const sig = String.fromCharCode(view.getUint8(pos), view.getUint8(pos+1), view.getUint8(pos+2), view.getUint8(pos+3));
        pos+=4;
        if (headerSize === 14) pos += 2;
        if (sig !== '.FIT') throw new Error('Invalid FIT signature');

        const dataEnd = headerSize + dataSize;
        pos = headerSize;

        const defMap = new Map();
        let lastTimestamp;
        const records = [];

        while (pos < dataEnd) {
          const header = view.getUint8(pos); pos += 1;

          if (header & 0x80) {
            const localNum = (header >> 5) & 0x03;
            const timeOffset = header & 0x1F;
            const def = defMap.get(localNum);
            if (!def) throw new Error('Compressed header refers to unknown local message: ' + localNum);

            let ts;
            if (lastTimestamp === undefined) ts = 0;
            else {
              ts = (lastTimestamp & ~31) + timeOffset;
              if (ts <= lastTimestamp) ts += 32;
            }
            lastTimestamp = ts;

            const {obj, bytesConsumed} = this._decodeData(view, pos, def, true, ts);
            pos += bytesConsumed;
            this._route(def.globalMsgNum, obj, records);
          } else {
            const isDefinition = (header & 0x40) !== 0;
            const hasDeveloper = (header & 0x20) !== 0;
            const localNum = header & 0x0F;

            if (isDefinition) {
              const reserved = view.getUint8(pos); pos+=1;
              const arch = view.getUint8(pos); pos+=1;
              const little = arch === 0;
              const globalMsgNum = view.getUint16(pos, little); pos+=2;

              const numFields = view.getUint8(pos); pos+=1;
              const fields = [];
              for (let i=0;i<numFields;i++) {
                const fieldNum = view.getUint8(pos); pos+=1;
                const size = view.getUint8(pos); pos+=1;
                const baseType = view.getUint8(pos); pos+=1;
                fields.push({num: fieldNum, size, baseTypeId: (baseType & 0x1F)});
              }

              const devFields = [];
              if (hasDeveloper) {
                const numDevFields = view.getUint8(pos); pos+=1;
                for (let i=0;i<numDevFields;i++) {
                  const dfNum = view.getUint8(pos); pos+=1;
                  const dfSize = view.getUint8(pos); pos+=1;
                  const dfIndex = view.getUint8(pos); pos+=1;
                  devFields.push({num: dfNum, size: dfSize, devIndex: dfIndex});
                }
              }

              defMap.set(localNum, {globalMsgNum, little, fields, devFields});
            } else {
              const def = defMap.get(localNum);
              if (!def) throw new Error('Data message refers to unknown local message: ' + localNum);

              const {obj, bytesConsumed} = this._decodeData(view, pos, def, false, undefined);
              pos += bytesConsumed;

              if (def.globalMsgNum === 20) {
                if (obj.timestamp !== undefined) lastTimestamp = obj.timestamp;
                else if (lastTimestamp !== undefined) obj.timestamp = lastTimestamp;
              }
              this._route(def.globalMsgNum, obj, records);
            }
          }
        }

        this._mapFieldDescriptions();

        return {
          records,
          devFieldDescriptions: this.devFieldDescriptions,
          fileIds: this.fileIds,
          deviceInfos: this.deviceInfos,
          fileCreators: this.fileCreators
        };
      }

      _route(globalMsgNum, obj, records){
        if (globalMsgNum === 20) records.push(obj);
        else if (globalMsgNum === 206) this.fieldDescObjs.push(obj);
        else if (globalMsgNum === 0) this.fileIds.push(obj);
        else if (globalMsgNum === 23) this.deviceInfos.push(obj);
        else if (globalMsgNum === 49) this.fileCreators.push(obj);
      }

      _decodeData(view, offset, def, isCompressed, compressedTs) {
        let pos = offset;
        const obj = { timestamp: undefined, fields: {}, dev: {}, _def: def };
        for (const fld of def.fields) {
          const baseId = fld.baseTypeId;
          const size = fld.size;
          if (isCompressed && fld.num === 253) { obj.timestamp = compressedTs; continue; }
          const value = this._readValue(view, pos, baseId, size, def.little);
          pos += size;
          if (fld.num === 253) { if (typeof value === 'number') obj.timestamp = value; }
          else obj.fields[fld.num] = value;
        }
        if (def.devFields && def.devFields.length) {
          for (const df of def.devFields) {
            const key = df.devIndex + ':' + df.num;
            const value = this._readDevValue(view, pos, df.size, def.little);
            pos += df.size;
            obj.dev[key] = value;
            this._devKeysUsed.add(key);
          }
        }
        return { obj, bytesConsumed: pos - offset };
      }

      _readValue(view, pos, baseId, size, little) {
        switch (baseId) {
          case 7: { const bytes = new Uint8Array(view.buffer, view.byteOffset + pos, size); let zero = bytes.indexOf(0); if (zero < 0) zero = bytes.length; return textDecoder.decode(bytes.subarray(0, zero)); }
          case 0: case 2: case 10: return view.getUint8(pos);
          case 1: return view.getInt8(pos);
          case 3: return view.getInt16(pos, little);
          case 4: case 11: return view.getUint16(pos, little);
          case 5: return view.getInt32(pos, little);
          case 6: case 12: return view.getUint32(pos, little);
          case 8: return view.getFloat32(pos, little);
          case 9: return view.getFloat64(pos, little);
          case 13: return view.getUint8(pos);
          case 14: { if (view.getBigInt64) return Number(view.getBigInt64(pos, little)); const lo = view.getUint32(pos, little), hi = view.getInt32(pos+4, little); return hi * 4294967296 + lo; }
          case 15: case 16: { if (view.getBigUint64) return Number(view.getBigUint64(pos, little)); const lo = view.getUint32(pos, little), hi = view.getUint32(pos+4, little); return hi * 4294967296 + lo; }
          default: return view.getUint8(pos);
        }
      }

      _readDevValue(view, pos, size, little) {
        if (size === 4) { const f = view.getFloat32(pos, little); if (Number.isFinite(f) && Math.abs(f) < 1e12) return f; return view.getInt32(pos, little); }
        else if (size === 2) return view.getInt16(pos, little);
        else if (size === 1) return view.getUint8(pos);
        else if (size === 8) { const d = view.getFloat64(pos, little); if (Number.isFinite(d)) return d; if (view.getBigInt64) return Number(view.getBigInt64(pos, little)); const lo = view.getUint32(pos, little), hi = view.getUint32(pos+4, little); return hi * 4294967296 + lo; }
        else return view.getUint8(pos);
      }

      _mapFieldDescriptions() {
        const candidates = Array.from(this._devKeysUsed);
        if (candidates.length === 0) return;
        const set = new Set(candidates);
        for (const obj of this.fieldDescObjs) {
          const nums1b=[], strings=[];
          for (const v of Object.values(obj.fields)) {
            if (typeof v === 'number' && Number.isInteger(v) && v>=0 && v<=255) nums1b.push(v);
            else if (typeof v === 'string' && v.length) strings.push(v.trim());
          }
          let matchedKey=null;
          for (let i=0;i<nums1b.length;i++){
            for (let j=0;j<nums1b.length;j++){
              if (i===j) continue;
              const key = nums1b[i]+':'+nums1b[j];
              if (set.has(key)){ matchedKey=key; break; }
            }
            if (matchedKey) break;
          }
          if (matchedKey){
            let name='', units='';
            if (strings.length===1){ const s=strings[0]; if (/^([cC]|degC|°C|Celsius|K|F|bpm|min\/km|km|m\/s|spm)$/i.test(s)) units=s; else name=s; }
            else if (strings.length>=2){ strings.sort((a,b)=>a.length-b.length); units=strings[0]; name=strings[strings.length-1]; }
            const ex=this.devFieldDescriptions.get(matchedKey)||{};
            if (name) ex.name=name;
            if (units) ex.units=units;
            // Capture scale/offset when provided (per FIT field_description: scale=6, offset=7)
            const sc = obj.fields && typeof obj.fields[6] === 'number' ? obj.fields[6] : undefined;
            const off = obj.fields && typeof obj.fields[7] === 'number' ? obj.fields[7] : undefined;
            if (Number.isFinite(sc) && sc !== 0) ex.scale = sc;
            if (Number.isFinite(off)) ex.offset = off;
            this.devFieldDescriptions.set(matchedKey, ex);
          }
        }
      }
    }

    class LineChart {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.series = [];
        this.dpr = Math.max(1, window.devicePixelRatio || 1);
        this.margins = {top:10, right:60, bottom:26, left:50};
        this.tooltip = {active:false, x:0, nearest:[]};

        this.zoomMode = false;
        this.dragging = false;
        this.selStartPx = 0;
        this.selEndPx = 0;
        this.crosshairDragging = false;
        this.onSelectRange = null;

        this.xRange = [0, 1];
        this.yLeft = [20, 40];
        this.yRight = [50, 180];

        this.elevSeries = [];
        this.hsiBgSeries = [];

        this.baseTime = 0;
        this.xAxisMode = 'delta'; // 'delta' or 'timeOfDay'

        this._bind();
        this.resize();
      }
      setZoomMode(on){ this.zoomMode = !!on; }
      _ensureRanges(){
        const ok = a => Array.isArray(a) && a.length===2 && isFinite(a[0]) && isFinite(a[1]) && a[1]>a[0];
        if (!ok(this.xRange)) this.xRange=[0,1];
        if (!ok(this.yLeft)) this.yLeft=[20,40];
        if (!ok(this.yRight)) this.yRight=[50,180];
      }
      setSeries(series, elevSeries = null){
        this.series = series || [];
        if (Array.isArray(elevSeries)) this.elevSeries = elevSeries;
        this._computeRanges();
        this.draw();
      }
      resize(){
        const rect = this.canvas.getBoundingClientRect();
        const cssW = Math.max(1, rect.width);
        const cssH = Math.max(1, rect.height);
        this.canvas.width = Math.max(1, Math.floor(cssW * this.dpr));
        this.canvas.height = Math.max(1, Math.floor(cssH * this.dpr));
        this.ctx.setTransform(this.dpr,0,0,this.dpr,0,0);
        this.draw();
      }
      _bind(){
        window.addEventListener('resize', () => this.resize(), {passive:true});

        this.canvas.addEventListener('pointerdown', (e)=>{
          const x = this._clientToCanvasX(e.clientX);
          if (this.zoomMode) {
            e.preventDefault();
            this.dragging = true;
            this.selStartPx = x;
            this.selEndPx = x;
            this.tooltip.active = false;
            this.canvas.setPointerCapture(e.pointerId);
            this.draw();
          } else {
            e.preventDefault();
            this.crosshairDragging = true;
            this.tooltip.active = true;
            this.tooltip.x = x;
            this._updateTooltipNearest();
            this.canvas.setPointerCapture(e.pointerId);
            this.draw();
          }
        }, {passive:false});

        this.canvas.addEventListener('pointermove', (e)=>{
          const x = this._clientToCanvasX(e.clientX);
          if (this.dragging) {
            e.preventDefault();
            this.selEndPx = x;
            this.draw();
          } else if (this.crosshairDragging || e.pointerType === 'mouse') {
            e.preventDefault();
            this.tooltip.active = true;
            this.tooltip.x = x;
            this._updateTooltipNearest();
            try {
              const [xMin,xMax] = this.xRange;
              const plotW = this._plotWidth();
              const dataX = xMin + ( (x - this.margins.left) / plotW ) * (xMax - xMin);
              updateMovingPositionOnMap(dataX);
            } catch (e) {}
            this.draw();
          }
        }, {passive:false});

        const endDrag = (e)=>{
          if (this.dragging) {
            e.preventDefault();
            this.dragging = false;
            const w = Math.abs(this.selEndPx - this.selStartPx);
            if (w > 6) {
              const x1 = this._pixToDataX(Math.min(this.selStartPx, this.selEndPx));
              const x2 = this._pixToDataX(Math.max(this.selStartPx, this.selEndPx));
              if (this.onSelectRange) this.onSelectRange([x1, x2]);
            }
          }
          if (this.crosshairDragging) {
            e.preventDefault();
            this.crosshairDragging = false;
          }
          try { this.canvas.releasePointerCapture(e.pointerId); } catch {}
        };
        this.canvas.addEventListener('pointerup', endDrag, {passive:false});
        this.canvas.addEventListener('pointercancel', endDrag, {passive:false});
        this.canvas.addEventListener('pointerleave', (e)=>{
          if (this.dragging || this.crosshairDragging) endDrag(e);
          else { this.tooltip.active=false; this.draw(); }
        }, {passive:false});
      }
      _clientToCanvasX(clientX){
        const rect = this.canvas.getBoundingClientRect();
        return (clientX - rect.left);
      }
      _plotWidth(){
        const W = this.canvas.clientWidth || (this.canvas.width/this.dpr);
        return Math.max(1, (W - this.margins.left - this.margins.right));
      }
      _pixToDataX(px){
        const [xMin,xMax]=this.xRange;
        const plotW = this._plotWidth();
        const rel = clamp((px - this.margins.left)/plotW, 0, 1);
        return xMin + rel * (xMax - xMin);
      }
      _computeRanges(){
        let xMin=Infinity, xMax=-Infinity;
        for (const s of this.series) if (s && s.visible && s.points && s.points.length) {
          xMin = Math.min(xMin, s.points[0].x);
          xMax = Math.max(xMax, s.points[s.points.length-1].x);
        }
        if (this.elevSeries && this.elevSeries.length){
          xMin = Math.min(xMin, this.elevSeries[0].x);
          xMax = Math.max(xMax, this.elevSeries[this.elevSeries.length-1].x);
        }
        if (!isFinite(xMin) || !isFinite(xMax) || xMin===xMax) { xMin=0; xMax=1; }
        
        // Store the actual data range for time calculations
        this.actualXMin = xMin;
        this.xRange = [xMin, xMax];

        let lmin=Infinity, lmax=-Infinity;
        for (const s of this.series) if (s && s.visible && s.axis==='left' && s.points && s.points.length){
          for (const p of s.points){ if (Number.isFinite(p.y)) { lmin=Math.min(lmin,p.y); lmax=Math.max(lmax,p.y); } }
        }
        if (!isFinite(lmin) || !isFinite(lmax)) { lmin=20; lmax=40; }
        const lstart = Math.floor(lmin);
        let lend = lmax;
        if (lend <= lstart) lend = lstart + 1;
        const spanL = Math.max(1e-6, lend - lstart);
        lend = lend + spanL*0.05;
        this.yLeft = [lstart, lend];

        let rmin=Infinity, rmax=-Infinity;
        for (const s of this.series) if (s && s.visible && s.axis==='right' && s.points && s.points.length){
          for (const p of s.points){ if (Number.isFinite(p.y)) { rmin=Math.min(rmin,p.y); rmax=Math.max(rmax,p.y); } }
        }
        if (!isFinite(rmin) || !isFinite(rmax) || rmin===rmax) { rmin=50; rmax=180; }
        const spanR = Math.max(1e-6, rmax - rmin);
        const padR = spanR*0.08;
        this.yRight = [rmin - padR, rmax + padR];
      }
      _sx(x){
        const [xMin,xMax]=this.xRange;
        const W = this.canvas.clientWidth || (this.canvas.width/this.dpr);
        return this.margins.left + ( (x - xMin) / Math.max(1e-9, (xMax-xMin)) ) * (W - this.margins.left - this.margins.right);
      }
      _syLeft(y){
        const [min,max]=this.yLeft;
        const H = this.canvas.clientHeight || (this.canvas.height/this.dpr);
        return (H - this.margins.bottom) - ( (y - min) / Math.max(1e-9, (max-min)) ) * (H - this.margins.top - this.margins.bottom);
      }
      _syRight(y){
        const [min,max]=this.yRight;
        const H = this.canvas.clientHeight || (this.canvas.height/this.dpr);
        return (H - this.margins.bottom) - ( (y - min) / Math.max(1e-9, (max-min)) ) * (H - this.margins.top - this.margins.bottom);
      }

      _drawElevationBackground(){
        if (!this.elevSeries || this.elevSeries.length < 2) return;

        const [xMin, xMax] = this.xRange;
        let emin = Infinity, emax = -Infinity;
        for (const p of this.elevSeries){
          if (p.x < xMin || p.x > xMax) continue;
          if (Number.isFinite(p.y)) { emin = Math.min(emin, p.y); emax = Math.max(emax, p.y); }
        }
        if (!isFinite(emin) || !isFinite(emax) || emax - emin <= 1e-9) return;

        const ctx = this.ctx;
        const H = this.canvas.clientHeight || (this.canvas.height/this.dpr);
        const plotTop = this.margins.top;
        const plotBottom = H - this.margins.bottom;

        const elevToY = (val)=>{
          const t = (val - emin) / (emax - emin);
          return plotBottom - t * (plotBottom - plotTop);
        };

        ctx.save();
        ctx.beginPath();
        let started = false;
        let firstX = null;
        let lastX = null;
        for (let i=0;i<this.elevSeries.length;i++){
          const p = this.elevSeries[i];
          if (p.x < xMin || p.x > xMax || !Number.isFinite(p.y)) continue;
          const x = this._sx(p.x);
          const y = elevToY(p.y);
          if (!started){ ctx.moveTo(x, y); started = true; firstX = x; }
          else ctx.lineTo(x, y);
          lastX = x;
        }
        if (started){
          ctx.lineTo(lastX, plotBottom);
          ctx.lineTo(firstX, plotBottom);
          ctx.closePath();
          ctx.fillStyle = getVar('--elev-fill', '#6b728029');
          ctx.fill();

          ctx.beginPath();
          started = false;
          const step = Math.max(1, Math.floor(this.elevSeries.length / 3000));
          for (let i=0;i<this.elevSeries.length;i+=step){
            const p = this.elevSeries[i];
            if (p.x < xMin || p.x > xMax || !Number.isFinite(p.y)) continue;
            const x = this._sx(p.x);
            const y = elevToY(p.y);
            if (!started){ ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
          }
          ctx.strokeStyle = getVar('--elev-stroke', '#6b728066');
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        ctx.restore();
      }

      _drawHSIBackground(){
        const hsiSeries = (this.series.find(s => s.id==='hsi') || {}).points || [];
        if (!hsiSeries.length) return;

        const [xMin, xMax] = this.xRange;
        const ctx = this.ctx;
        const W = this.canvas.clientWidth || (this.canvas.width/this.dpr);
        const H = this.canvas.clientHeight || (this.canvas.height/this.dpr);
        const plotLeft = this.margins.left;
        const plotRight = W - this.margins.right;
        const plotTop = this.margins.top;
        const plotBottom = H - this.margins.bottom;

        const zoneOf = (v)=> {
          const c = Number.isFinite(v) ? v : NaN;
          if (!Number.isFinite(c)) return null;
          if (c < 0.1) return null; // keep background white when HSI < 0.1
          if (c <= 1) return 'green';
          if (c <= 3) return 'orange';
          if (c <= 7) return 'red-med';
          return 'red-dark';
        };
        const colorOf = (zone)=>{
          if (zone==='green') return getVar('--hsi-bg-green', '#2e7d321a');
          if (zone==='orange') return getVar('--hsi-bg-orange', '#ef6c001a');
          if (zone==='red-med') return getVar('--hsi-bg-red-med', '#e539351a');
          if (zone==='red-dark') return getVar('--hsi-bg-red-dark', '#b91c1c1a');
          return null;
        };

        let segments = [];
        for (let i=0;i<hsiSeries.length-1;i++){
          const p1 = hsiSeries[i], p2 = hsiSeries[i+1];
          if (p2.x <= xMin || p1.x >= xMax) continue;
          const x1 = Math.max(xMin, p1.x);
          const x2 = Math.min(xMax, p2.x);
          if (x2 <= x1) continue;
          const z = zoneOf(p1.y);
          if (!z) continue;
          segments.push({x1, x2, zone:z});
        }
        if (!segments.length) return;

        const merged = [];
        let cur = null;
        for (const s of segments){
          if (!cur) cur = {...s};
          else if (s.zone===cur.zone && Math.abs(s.x1 - cur.x2) < 1e-6) {
            cur.x2 = s.x2;
          } else {
            merged.push(cur);
            cur = {...s};
          }
        }
        if (cur) merged.push(cur);

        ctx.save();
        ctx.beginPath();
        ctx.rect(plotLeft, plotTop, plotRight - plotLeft, plotBottom - plotTop);
        ctx.clip();

        for (const s of merged){
          const x1 = this._sx(s.x1);
          const x2 = this._sx(s.x2);
          const c = colorOf(s.zone);
          if (!c) continue;
          ctx.fillStyle = c;
          ctx.fillRect(x1, plotTop, Math.max(0, x2 - x1), plotBottom - plotTop);
        }
        ctx.restore();
      }

      draw(){
        this._ensureRanges();

        const ctx = this.ctx;
        const W = this.canvas.clientWidth || (this.canvas.width/this.dpr);
        const H = this.canvas.clientHeight || (this.canvas.height/this.dpr);

        ctx.save();
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        ctx.setTransform(this.dpr,0,0,this.dpr,0,0);

        // Compute ticks once
        const [xMin,xMax] = this.xRange;
        const xTicks = niceTicks(xMin, xMax, 6);
        const lTicks = niceTicks(this.yLeft[0], this.yLeft[1], 5);
        const rTicks = niceTicks(this.yRight[0], this.yRight[1], 5);

        // Clip and draw backgrounds + series
        ctx.save();
        ctx.beginPath();
        ctx.rect(this.margins.left, this.margins.top, W - this.margins.left - this.margins.right, H - this.margins.top - this.margins.bottom);
        ctx.clip();

        // Backgrounds
        this._drawHSIBackground();
        this._drawElevationBackground();

        // Series lines
        for (const s of this.series) {
          if (!s || !s.visible || !s.points || s.points.length===0) continue;
          ctx.strokeStyle = s.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          let first = true;
          const sy = (s.axis==='left') ? (y)=>this._syLeft(y) : (y)=>this._syRight(y);
          const maxPts = 5000;
          const step = Math.max(1, Math.floor(s.points.length / maxPts));
          for (let i=0;i<s.points.length;i+=step) {
            const p = s.points[i];
            if (!Number.isFinite(p.y)) continue;
            const x = this._sx(p.x);
            const y = sy(p.y);
            if (first) { ctx.moveTo(x,y); first=false; } else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }

        // Selection rectangle
        if (this.dragging) {
          const x1 = this.selStartPx, x2 = this.selEndPx;
          const left = Math.min(x1,x2), right = Math.max(x1,x2);
          const top = this.margins.top, bottom = H - this.margins.bottom;
          ctx.fillStyle = getVar('--select','#4fc3f733');
          ctx.strokeStyle = getVar('--select-border','#4fc3f7aa');
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.rect(left, top, right-left, bottom-top); ctx.fill(); ctx.stroke();
        }

        // Tooltip/crosshair
        if (this.tooltip.active && !this.dragging) {
          const xPix = this.tooltip.x;
          ctx.strokeStyle = '#00000033';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(xPix, this.margins.top);
          ctx.lineTo(xPix, H - this.margins.bottom);
          ctx.stroke();

          const info = this.tooltip.nearest || [];
          if (info.length) {
            const pad = 6;
            const lines = [];
            let tStr = '';
            for (const item of info) if (item.id === 'time') tStr = item.text;
            if (tStr) lines.push(tStr);
            for (const item of info) if (item.id!=='time') lines.push(item.text);
            ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial';
            const widths = lines.map(s=>ctx.measureText(s).width);
            const bw = (widths.length ? Math.max(...widths) : 0) + pad*2;
            const bh = lines.length*16 + pad*2;
            let bx = xPix + 8, by = this.margins.top + 8;
            const Wc = this.canvas.clientWidth || (this.canvas.width/this.dpr);
            if (bx + bw > Wc - 4) bx = xPix - 8 - bw;
            if (bx < 4) bx = 4;
            ctx.fillStyle = '#ffffffee';
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.rect(bx, by, bw, bh); ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#111827';
            for (let i=0;i<lines.length;i++){
              ctx.fillText(lines[i], bx+pad, by+pad+ (i*16));
            }
          }
        }

        ctx.restore(); // end clip

        // Grid lines
        ctx.strokeStyle = getVar('--grid','#2a2f37');
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (const tv of xTicks) {
          const x = this._sx(tv);
          ctx.moveTo(x, this.margins.top);
          ctx.lineTo(x, H - this.margins.bottom);
        }
        ctx.stroke();

        ctx.beginPath();
        for (const yv of lTicks) {
          const y = this._syLeft(yv);
          ctx.moveTo(this.margins.left, y);
          ctx.lineTo(W - this.margins.right, y);
        }
        ctx.stroke();

        // Axis labels
        ctx.fillStyle = '#475569';
        ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (const tv of xTicks) {
          const x = this._sx(tv);
          const isOriginTick = Math.abs(tv - this.xRange[0]) < 1e-9;
          const willDrawCustomOrigin = (this.xAxisMode === 'timeOfDay' && this.baseTime > 0) || (this.xAxisMode !== 'timeOfDay');
          // Skip drawing the tick label at the origin if we will draw a custom origin label below
          if (willDrawCustomOrigin && isOriginTick) continue;

          let labelText;
          if (this.xAxisMode === 'timeOfDay' && this.baseTime > 0) {
            const d = new Date((this.baseTime + tv + FIT_EPOCH_OFFSET) * 1000);
            labelText = fmtTOD(d);
          } else {
            // For delta time, show elapsed time from the visible start (accounting for trim)
            const xMin = this.xRange[0];
            const relativeTime = tv - xMin;
            labelText = fmtHMS(Math.max(0, relativeTime));
          }
          ctx.fillText(labelText, x, H - this.margins.bottom + 6);
        }
        // Draw origin label at the visible start
        if (this.xAxisMode === 'timeOfDay' && this.baseTime > 0) {
          const originDate = new Date((this.baseTime + this.xRange[0] + FIT_EPOCH_OFFSET) * 1000);
          const originLabel = fmtTOD(originDate);
          ctx.textAlign = 'left';
          ctx.fillText(originLabel, this.margins.left, H - this.margins.bottom + 6);
          ctx.textAlign = 'center';
        } else if (this.xAxisMode !== 'timeOfDay') {
          // Delta time mode: always show 00:00 at origin
          ctx.textAlign = 'left';
          ctx.fillText('00:00', this.margins.left, H - this.margins.bottom + 6);
          ctx.textAlign = 'center';
        }
        // Subtle origin marker at the visible start on the x-axis
        if (isFinite(this.xRange[0]) && isFinite(this.xRange[1]) && this.xRange[1] > this.xRange[0]) {
          const y0 = H - this.margins.bottom;
          const x0 = this.margins.left;
          ctx.strokeStyle = getVar('--grid','#2a2f37');
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x0, y0 - 6);
          ctx.lineTo(x0, y0);
          ctx.stroke();
        }

        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (const yv of lTicks) {
          const y = this._syLeft(yv);
          ctx.fillText((Math.round(yv*10)/10).toFixed(1), this.margins.left - 6, y);
        }

        ctx.textAlign = 'left';
        for (const yv of rTicks) {
          const y = this._syRight(yv);
          ctx.fillText((Math.round(yv*10)/10).toFixed(1), W - this.margins.right + 6, y);
        }

        ctx.restore();
      }
      _updateTooltipNearest(){
        const [xMin,xMax] = this.xRange;
        const plotW = this._plotWidth();
        const x = xMin + ( (this.tooltip.x - this.margins.left) / plotW ) * (xMax - xMin);
        const nearest = [];
        let timeText;
        if (this.xAxisMode === 'timeOfDay' && this.baseTime > 0) {
          const d = new Date((this.baseTime + x + FIT_EPOCH_OFFSET) * 1000);
          timeText = 't = ' + fmtTOD(d);
        } else {
          const relativeTime = x - xMin;
          timeText = 't = ' + fmtHMS(Math.max(0, relativeTime));
        }
        nearest.push({id:'time', text: timeText});

        for (const s of this.series) {
          if (!s || !s.visible || !s.points || !s.points.length===0) continue;
          const idx = this._bisectX(s.points, x);
          let best = null;
          for (const j of [idx-1, idx, idx+1]) {
            if (j>=0 && j < s.points.length) {
              const p = s.points[j];
              const dx = Math.abs(p.x - x);
              if (!best || dx < best.dx) best = {p, dx};
            }
          }
          if (best) {
            const val = best.p.y;
            const vtxt = s.fmt ? s.fmt(val) : String(val);
            nearest.push({id:s.id, text:`${s.name}: ${vtxt}`});
          }
        }
        this.tooltip.nearest = nearest;
      }
      _bisectX(arr, x){
        let lo=0, hi=arr.length-1;
        while (lo<=hi){
          const mid = (lo+hi)>>1;
          if (arr[mid].x < x) lo = mid+1;
          else hi = mid-1;
        }
        return lo;
      }
    }

    const fileInput = document.getElementById('file');
const androidFsBtn = document.getElementById('androidFsBtn');
const isAndroid = /Android/i.test(navigator.userAgent);
const canFS = !!(window.showOpenFilePicker);
if (androidFsBtn && isAndroid && canFS){
  androidFsBtn.style.display = 'inline-block';
  // Optional: hide the fallback input on Android if FS API is available
  try { if (fileInput) fileInput.style.display = 'none'; } catch(_) {}
  androidFsBtn.addEventListener('click', async (e)=>{
    e.preventDefault();
    try{
      const [hdl] = await window.showOpenFilePicker({
        multiple: false,
        excludeAcceptAllOption: true,
        types: [{
          description: 'FIT Files',
          accept: {
            'application/fit': ['.fit'],
            'application/vnd.ant.fit': ['.fit']
          }
        }]
      });
      if (hdl){
        const file = await hdl.getFile();
        await handleFitFile(file);
      }
    }catch(err){
      // Fallback to input if user cancels or FS API fails
      try{ if (fileInput) fileInput.click(); }catch(_){ }
    }
  });
}
    const messageEl = document.getElementById('message');
    const statsEl = document.getElementById('stats');
    const resetBtn = document.getElementById('resetBtn');
    const zoomModeBtn = document.getElementById('zoomModeBtn');
    const zoomClearBtn = document.getElementById('zoomClearBtn');
    const mapBtn = document.getElementById('mapBtn');
    const missingMsgEl = document.getElementById('missingMsg');
    function setMissingMsg(fields){
      if (!missingMsgEl) return;
      if (!fields || !fields.length) { missingMsgEl.textContent=''; return; }
      missingMsgEl.textContent = 'The following fields were not found in the FIT file: ' + fields.join(', ');
    }
    function showIf(el, on){ if (el) el.style.display = on ? '' : 'none'; }
    const smoothSlider = document.getElementById('smoothSlider');
    const smoothText = document.getElementById('smoothText');
    const deviceNameEl = document.getElementById('deviceName');
    const activityTimeEl = document.getElementById('activityTime');

    const canvas = document.getElementById('chart');
    const chart = new LineChart(canvas);

    // Leaflet map init (lazy, only when coordinates are present)
    let map, routeLayer, selectionLayer, movingMarker, startMarker, endMarker, legendControl, routeGradientGroup;
    function ensureMap(){
      const status = document.getElementById('mapStatus');
      if (map) { return map; }
      const el = document.getElementById('map');
      if (!el) { if (status) status.textContent = 'Map container not found'; return null; }
        if (typeof L === 'undefined') { if (status) status.textContent = 'Leaflet not loaded'; return null; }
          map = L.map('map', { zoomControl: true, attributionControl: true });
          if (status) status.textContent = 'Map initialized';
          
          // Click on map to sync graph position
          map.on('click', (e)=>{
            try {
              if (!current.routePoints || !current.routePoints.length) return;
              const {lat, lng} = e.latlng;
              let best=null;
              for (const p of current.routePoints){
                const dx = p.lat - lat;
                const dy = p.lon - lng;
                const d2 = dx*dx + dy*dy;
                if (!best || d2 < best.d2) best = {p, d2};
              }
              if (!best) return;
              const [xMin,xMax] = chart.xRange;
              const W = chart.canvas.clientWidth || (chart.canvas.width/chart.dpr);
              const plotW = Math.max(1, (W - chart.margins.left - chart.margins.right));
              const rel = (best.p.x - xMin) / Math.max(1e-9, (xMax - xMin));
              const xp = chart.margins.left + rel * plotW;
              chart.tooltip.active = true;
              chart.tooltip.x = xp;
              chart._updateTooltipNearest();
              updateMovingPositionOnMap(best.p.x);
              chart.draw();
            } catch (err) { console.warn(err); }
          });
          
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; OpenStreetMap contributors'
          }).addTo(map);
          
          // Base layers
          routeLayer = L.polyline([], { color: '#2563eb', weight: 6, opacity: 0.5 }).addTo(map);
          routeGradientGroup = L.layerGroup().addTo(map);
          selectionLayer = L.polyline([], { color: '#f59e0b', weight: 6, opacity: 0.9 }).addTo(map);
          
          // Legend (compact, selector on the right, color previews only)
          legendControl = L.control({position:'bottomright'});
          legendControl.onAdd = function(){
            const div = L.DomUtil.create('div','leaflet-control legend');
            // Compact container
            Object.assign(div.style, {
              background: 'rgba(255,255,255,0.95)',
              padding: '4px 6px',
              borderRadius: '6px',
              fontSize: '12px',
              color: '#111827',
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              flexWrap: 'wrap'
            });
            
            // Left group (labels)
            const leftHTML = `
<div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap">
  <div><span style="display:inline-block;width:10px;height:10px;background:#2563eb;margin-right:6px;border-radius:2px;"></span>Route</div>
  <div><span style="display:inline-block;width:10px;height:10px;background:#f59e0b;margin-right:6px;border-radius:2px;"></span>Selection</div>
  <div><span style="display:inline-block;width:10px;height:10px;background:#7c3aed;border:2px solid #7c3aed;border-radius:50%;margin-right:6px;"></span>Position</div>
  <div><span style="display:inline-block;width:10px;height:10px;background:#ffffff;border:2px solid #16a34a;margin-right:6px;border-radius:50%;"></span>Start</div>
  <div><span style="display:inline-block;width:10px;height:10px;background:#ffffff;border:2px solid #ef4444;margin-right:6px;border-radius:50%;"></span>Finish</div>
</div>
`;
            
            // Right group (selector + swatches)
            const rightHTML = `
<div style="margin-left:auto;display:flex;align-items:center;gap:8px;flex-wrap:nowrap">
  <label for="mapGradientSelect" style="margin:0;color:#111827">Route color:</label>
  <select id="mapGradientSelect" style="padding:4px 6px;border:1px solid #cbd5e1;border-radius:6px">
    <option value="none" selected>None</option>
    <option value="hr">Heart Rate</option>
    <option value="pace">Pace (fixed bands)</option>
  </select>
  <!-- HR gradient swatch -->
  <div id="hrRamp" title="Heart rate gradient"
        style="width:80px;height:8px;border-radius:4px;border:1px solid #cbd5e1;
              background:linear-gradient(90deg,#2563eb 0%, #06b6d4 25%, #22c55e 50%, #eab308 75%, #ef4444 100%);
              display:none"></div>
  <!-- Pace band swatches -->
  <div id="paceBands" title="Pace bands" style="display:none;align-items:center;gap:2px">
    <span style="width:14px;height:8px;background:#2563eb;border:1px solid #cbd5e1;border-radius:2px"></span>
    <span style="width:14px;height:8px;background:#06b6d4;border:1px solid #cbd5e1;border-radius:2px"></span>
    <span style="width:14px;height:8px;background:#22c55e;border:1px solid #cbd5e1;border-radius:2px"></span>
    <span style="width:14px;height:8px;background:#eab308;border:1px solid #cbd5e1;border-radius:2px"></span>
    <span style="width:14px;height:8px;background:#ef4444;border:1px solid #cbd5e1;border-radius:2px"></span>
  </div>
</div>
`;
            
            div.innerHTML = leftHTML + rightHTML;
            return div;
          };
          legendControl.addTo(map);
          
          // Hook selector + preview toggles
          setTimeout(()=>{
            const sel = document.getElementById('mapGradientSelect');
            const ramp = document.getElementById('hrRamp');
            const bands = document.getElementById('paceBands');
            const apply = ()=>{
              if (!current.routePoints || current.routePoints.length<2) return;
              const latlngs = current.routePoints.map(p=>[p.lat, p.lon]);
              let values=null;
              if (sel.value === 'hr') values = buildGradientValues('hr');
              else if (sel.value === 'pace') values = buildGradientValues('pace');
              updateRouteOnMap(latlngs, values);
              // Preview visibility
              if (ramp) ramp.style.display = sel.value==='hr' ? 'inline-block' : 'none';
              if (bands) bands.style.display = sel.value==='pace' ? 'inline-flex' : 'none';
            };
            if (sel) sel.addEventListener('change', apply);
            // Initialize preview (defaults to "None")
            if (ramp) ramp.style.display = 'none';
            if (bands) bands.style.display = 'none';
          }, 0);
          
          return map;
        }
    function clearMapLayers(){
      try {
        const m = ensureMap(); if (!m) return;
        if (routeLayer) routeLayer.setLatLngs([]);
        if (selectionLayer) selectionLayer.setLatLngs([]);
        try { if (routeGradientGroup) routeGradientGroup.clearLayers(); } catch(e){}
        try { if (startMarker) { m.removeLayer(startMarker); startMarker=null; } } catch(e){}
        try { if (endMarker) { m.removeLayer(endMarker); endMarker=null; } } catch(e){}
        try { if (movingMarker) { m.removeLayer(movingMarker); movingMarker=null; } } catch(e){}
        const status = document.getElementById('mapStatus'); if (status) status.textContent = 'Map reset';
      } catch(e){}
    }
    function updateRouteOnMap(latlngs, values){
      const status = document.getElementById('mapStatus');
      try {
        if (!Array.isArray(latlngs) || latlngs.length < 2) { if (status) status.textContent = 'No route points'; return; }
        const m = ensureMap(); if (!m) { if (status) status.textContent = 'Map not available'; return; }
        // Filter invalid latlngs and keep index mapping
        const idxs = [];
        const filtered = [];
        for (let i=0;i<latlngs.length;i++){
          const p = latlngs[i];
          if (Array.isArray(p) && isFinite(p[0]) && isFinite(p[1]) && Math.abs(p[0])<=90 && Math.abs(p[1])<=180) { filtered.push(p); idxs.push(i); }
        }
        if (filtered.length < 2) { if (status) status.textContent = 'No valid route points'; return; }
        if (status) status.textContent = `Route points: ${filtered.length} (first ${filtered[0][0].toFixed(5)}, ${filtered[0][1].toFixed(5)})`;
        // Clear gradient and selection groups and set base route
        try { routeGradientGroup.clearLayers(); } catch (e) {}
        try { selectionLayer.setLatLngs([]); } catch(e){}
        routeLayer.setLatLngs(filtered);
        addStartFinishMarkers(filtered);
        // Recreate start/finish markers after clearing overlays for top stacking order
        try { routeGradientGroup.clearLayers(); } catch (e) {}
        routeLayer.setLatLngs(filtered);
        // Remove any existing markers; we'll add after gradient so they sit on top
        try {
          if (startMarker) { map.removeLayer(startMarker); startMarker=null; }
          if (endMarker) { map.removeLayer(endMarker); endMarker=null; }
        } catch (e) {}
        // Auto-fit when no selection (before gradient to ensure renderer has bounds)
        if (!current.selection || !current.selection.length) {
          try { m.fitBounds(routeLayer.getBounds(), { padding: [20,20] }); } catch(e) {}
        }
        // Optional gradient based on values (align to filtered indices), defer to next frame to avoid renderer-bounds timing issues
        const buildGradient = ()=>{
          const status = document.getElementById('mapStatus');
          const selEl = document.getElementById('mapGradientSelect');
          const mode = selEl ? selEl.value : 'none';
          
          // If "None", keep only the base route and bail out.
          if (mode === 'none') {
            if (status) status.textContent = 'Route color: None';
            return;
          }
          // (rest of the function stays the same) const buildGradient = ()=>{

          let useFiltered = filtered.slice();
          let useIdxs = idxs.slice();
          // If selection is active and HR mode, restrict gradient to selection window
          if (current.selection && current.selection.length===2 && mode==='hr'){
            const [sx,ex] = current.selection;
            const seg = [];
            const idxSeg = [];
            for (let p=0;p<filtered.length;p++){
              const idx = idxs[p];
              const rp = current.routePoints && current.routePoints[idx];
              const t = rp ? rp.x : null;
              if (t!=null && t>=sx && t<=ex){ seg.push(filtered[p]); idxSeg.push(idx); }
            }
            if (seg.length>=2){ useFiltered = seg; useIdxs = idxSeg; }
          }
          // Determine values to color by
          let useVals = null;
          if (Array.isArray(values) && values.length === latlngs.length){
            useVals = useIdxs.map(i=> values[i]);
          } else if (mode==='hr' || mode==='pace'){
            const built = buildGradientValues(mode) || [];
            if (built.length === (current.routePoints ? current.routePoints.length : 0)){
              useVals = useIdxs.map(i=> built[i]);
            }
          }
          if (!useVals){ if (status) status.textContent = 'No gradient values'; return; }
          try {
            const finitePairs = [];
            for (let i=0;i<useFiltered.length;i++){
              const v = useVals[i];
              if (Number.isFinite(v)) finitePairs.push({i, v});
            }
            if (finitePairs.length < 2) { if (status) status.textContent = 'Not enough gradient values'; return; }
            const vmin = Math.min(...finitePairs.map(p=>p.v));
            const vmax = Math.max(...finitePairs.map(p=>p.v));
            // 5-stop colormap: blue → cyan → green → yellow → red
            const stops = [
              {t:0.00, c:[37,99,235]},   // #2563eb
              {t:0.25, c:[6,182,212]},   // #06b6d4 cyan
              {t:0.50, c:[34,197,94]},   // #22c55e green
              {t:0.75, c:[234,179,8]},   // #eab308 yellow
              {t:1.00, c:[239,68,68]},   // #ef4444 red
            ];
            const colorForValue = (val)=>{
              if (!Number.isFinite(val) || vmax<=vmin) return 'rgba(37,99,235,1)';
              const t = (val - vmin) / Math.max(1e-9, (vmax - vmin));
              let a=stops[0], b=stops[stops.length-1];
              for (let s=1;s<stops.length;s++){ if (t<=stops[s].t){ b=stops[s]; a=stops[s-1]; break; } }
              const lt = (t - a.t) / Math.max(1e-9, (b.t - a.t));
              const rr = Math.round(a.c[0] + (b.c[0]-a.c[0])*lt);
              const gg = Math.round(a.c[1] + (b.c[1]-a.c[1])*lt);
              const bb = Math.round(a.c[2] + (b.c[2]-a.c[2])*lt);
              return `rgb(${rr},${gg},${bb})`;
            };
            // Draw segments over contiguous valid points
            for (let k=1;k<finitePairs.length;k++){
              const i0 = finitePairs[k-1].i, i1 = finitePairs[k].i;
              const seg = [useFiltered[i0], useFiltered[i1]];
              const color = colorForValue(finitePairs[k].v);
              const poly = L.polyline(seg, { color, weight: 6, opacity: 1.0 });
              routeGradientGroup.addLayer(poly);
            }
          } catch (e) { if (status) status.textContent = 'Error building gradient'; }
        };
        try { requestAnimationFrame(()=>{ buildGradient(); addStartFinishMarkers(filtered); }); } catch(e) { buildGradient(); addStartFinishMarkers(filtered); }
      } catch (err) {
        if (status) status.textContent = 'updateRouteOnMap error';
        console.error(err);
      }
    }
    function buildGradientValues(kind){
      if (!current.routePoints || current.routePoints.length<2) return null;
      const values = [];
      if (kind === 'hr'){
        for (const p of current.routePoints){ let nearest=null; for (const pt of current.hrRaw||[]){ const dx=Math.abs(pt.x - p.x); if (!nearest || dx<nearest.dx) nearest={v:pt.y, dx}; } values.push(nearest? nearest.v : NaN); }
      } else if (kind === 'pace'){
        // Pace fixed-band coloring using minutes per km with outlier clamping
        // Clamp pace to [3.0, 12.0] min/km so brief stops don’t dominate color scaling
        // Bands: ≤4:00 (<=4.0) blue; 4.0–4.5 cyan; 4.5–5.0 green; 5.0–6.0 yellow; >6.0 red
        for (const p of current.routePoints){
          let nearest=null; for (const pt of current.paceRaw||[]){ const dx=Math.abs(pt.x - p.x); if (!nearest || dx<nearest.dx) nearest={v:pt.y, dx}; }
          let v = nearest? nearest.v : NaN; // min/km
          if (!Number.isFinite(v)) { values.push(NaN); continue; }
          v = clamp(v, 3.0, 12.0);
          // Map band to nominal value to drive color scale if needed
          if (v <= 4.0) values.push(4.0);
          else if (v <= 4.5) values.push(4.5);
          else if (v <= 5.0) values.push(5.0);
          else if (v <= 6.0) values.push(6.0);
          else values.push(7.0);
        }
      }
      return values;
    }
    function updateSelectedSegmentOnMap(range){
      const m = ensureMap(); if (!m) return;
      if (!range || !Array.isArray(range) || range.length!==2 || !current.routePoints || !current.routePoints.length){
        selectionLayer.setLatLngs([]);
        try { if (routeLayer) routeLayer.setStyle({opacity: 0.5}); } catch(e){}
        return;
      }
      const [x1, x2] = range;
      const seg = [];
      for (const p of current.routePoints){ if (p.x>=x1 && p.x<=x2) seg.push([p.lat, p.lon]); }
      selectionLayer.setLatLngs(seg);
      try { if (routeLayer) routeLayer.setStyle({opacity: 0.8}); } catch(e){}
      if (seg.length>1) m.fitBounds(selectionLayer.getBounds(), { padding: [20,20] });
    }
    function addStartFinishMarkers(points){
      const m = ensureMap(); if (!m || !points || points.length<2) return;
      try { if (startMarker) m.removeLayer(startMarker); } catch(e){}
      try { if (endMarker) m.removeLayer(endMarker); } catch(e){}
      const first = points[0];
      const last = points[points.length-1];
      startMarker = L.circleMarker(first, { radius:7, color:'#16a34a', weight:3, fill:true, fillColor:'#ffffff', fillOpacity:1, opacity:1 }).addTo(m).bindTooltip('Start', {permanent:false, direction:'top'});
      endMarker = L.circleMarker(last, { radius:7, color:'#ef4444', weight:3, fill:true, fillColor:'#ffffff', fillOpacity:1, opacity:1 }).addTo(m).bindTooltip('Finish', {permanent:false, direction:'top'});
      try { if (startMarker.bringToFront) startMarker.bringToFront(); if (endMarker.bringToFront) endMarker.bringToFront(); } catch(e){}
    }
    function updateMovingPositionOnMap(x){
      const m = ensureMap(); if (!m) return;
      if (!current.routePoints || !current.routePoints.length) return;
      // find nearest by x
      let best=null; for (const p of current.routePoints){ const dx = Math.abs(p.x - x); if (!best || dx < best.dx) best = {p, dx}; }
      if (!best) return;
      const latlng = [best.p.lat, best.p.lon];
      if (!movingMarker){
        movingMarker = L.circleMarker(latlng, { radius:8, color:'#7c3aed', weight:2, fill:true, fillColor:'#7c3aed', fillOpacity:1.0 }).addTo(m);
      } else {
        movingMarker.setLatLng(latlng);
      }
      try { if (movingMarker.bringToFront) movingMarker.bringToFront(); } catch(e){}
    }

    const toggles = {
      hr:   document.getElementById('toggle-hr'),
      core: document.getElementById('toggle-core'),
      skin: document.getElementById('toggle-skin'),
      hsi:  document.getElementById('toggle-hsi'),
      dist: document.getElementById('toggle-dist'),
      pace: document.getElementById('toggle-pace'),
      speed: document.getElementById('toggle-speed'),
      power: document.getElementById('toggle-power'),
      cad:  document.getElementById('toggle-cad'),
      trim: document.getElementById('toggle-trim'),
      xaxis: document.getElementById('toggle-xaxis'),
      mapGradientHR: null,
      mapGradientPace: null,
    };

    const toggleStates = {
      hr:   document.getElementById('state-hr'),
      core: document.getElementById('state-core'),
      skin: document.getElementById('state-skin'),
      hsi:  document.getElementById('state-hsi'),
      dist: document.getElementById('state-dist'),
      pace: document.getElementById('state-pace'),
      speed: document.getElementById('state-speed'),
      power:  document.getElementById('state-power'),
      cad:  document.getElementById('state-cad'),
      trim: document.getElementById('state-trim'),
      xaxis: document.getElementById('state-xaxis'),
    };

    function refreshToggleStates(){
      for (const [key, el] of Object.entries(toggleStates)) {
        const on = !!toggles[key]?.checked;
        if (el) el.textContent = on ? 'On' : 'Off';
      }
    }

    for (const el of Object.values(toggles)) {
      if (!el) continue;
      if (el.id !== 'toggle-xaxis') {
        el.addEventListener('change', ()=>{ 
          refreshToggleStates(); 
          if (el.id === 'toggle-trim') updateActivityTimeForTrim();
          renderChart(); 
          updateStatsUI(); 
        });
      }
    }
    if (toggles.xaxis) toggles.xaxis.addEventListener('change', () => {
      current.xAxisMode = toggles.xaxis.checked ? 'timeOfDay' : 'delta';
      refreshToggleStates();
      renderChart();
    });
    refreshToggleStates();

    let current = {
      records: [],
      devDesc: new Map(),
      fileIds: [],
      deviceInfos: [],
      fileCreators: [],
      manufacturer: null,

      baseTime: 0,

      hrRaw:   [],
      coreRaw: [],
      skinRaw: [],
      hsiRaw:  [],
      distRaw: [],
      paceRaw: [],
      speedRaw: [],
      powerRaw: [],
      cadRaw:  [],
      elevRaw: [],

      hrSeries:   [],
      coreSeries: [],
      skinSeries: [],
      hsiSeries:  [],
      distSeries: [],
      paceSeries: [],
      speedSeries: [],
      powerSeries: [],
      cadSeries:  [],
      elevSeries: [],

      coreKey: null,
      skinKey: null,
      coreScale: 1,
      skinScale: 1,
      coreOffset: 0,
      skinOffset: 0,

      tauSec: 0,
      cutoffX: 0,
      selection: null,

      zoomMode: false,
      xAxisMode: 'delta',
    };

    function setSmoothingUI(tau){
      current.tauSec = Math.max(0, tau||0);
      smoothText.textContent = 'Smoothing: ' + fmtS(current.tauSec);
    }
    function sliderToTau(val){
      const pct = clamp(Number(val)||0, 0, 100) / 100;
      return pct * 30;
    }
    smoothSlider.addEventListener('input', ()=>{
      const tau = sliderToTau(smoothSlider.value);
      setSmoothingUI(tau);
      recalcSmoothing();
      renderChart();
      updateStatsUI();
    });

    zoomModeBtn.addEventListener('click', ()=>{
      current.zoomMode = !current.zoomMode;
      chart.setZoomMode(current.zoomMode);
      zoomModeBtn.textContent = current.zoomMode ? 'Zoom: On' : 'Zoom: Off';
      messageEl.textContent = current.zoomMode
        ? 'Zoom mode is ON. Drag to select a time range. Use “Clear Zoom” to reset.'
        : 'Zoom mode is OFF. Slide your finger across the graph to inspect values.';
    });

    zoomClearBtn.addEventListener('click', ()=>{
      current.selection = null;
      zoomClearBtn.disabled = true;
      try { updateSelectedSegmentOnMap(null); } catch (e) {}
      try {
        if (current.routePoints && current.routePoints.length>1) {
          const latlngs = current.routePoints.map(p=>[p.lat, p.lon]);
          updateRouteOnMap(latlngs);
        }
      } catch (e) {}
      renderChart();
      updateStatsUI();
    });

    resetBtn.addEventListener('click', ()=>{
      fileInput.value = '';
      messageEl.textContent = 'Load a .FIT file. Zoom mode is OFF by default so you can slide across the graph to see values. Turn Zoom mode ON to drag-select a time range. All parsing and rendering happen locally.';
      statsEl.textContent = '';
      deviceNameEl.textContent = '';
      activityTimeEl.textContent = '';
      activityTimeEl.style.display = 'none';
      mapBtn.disabled = true;
      zoomClearBtn.disabled = true;
      zoomModeBtn.disabled = true;
      resetBtn.disabled = true;
      current = {
        records: [], devDesc: new Map(), fileIds: [], deviceInfos: [], fileCreators: [],
        baseTime: 0,
        hrRaw: [], coreRaw: [], skinRaw: [], hsiRaw: [], distRaw: [], paceRaw: [], speedRaw: [], cadRaw: [], elevRaw: [],
        hrSeries: [], coreSeries: [], skinSeries: [], hsiSeries: [], distSeries: [], paceSeries: [], speedSeries: [], cadSeries: [], elevSeries: [],
        coreKey: null, skinKey: null, coreScale: 1, skinScale: 1, coreOffset: 0, skinOffset: 0,
        tauSec: 0, cutoffX: 0, selection: null, zoomMode: false, xAxisMode: 'delta'
      };
      toggles.xaxis.checked = false;
      refreshToggleStates();
      chart.setZoomMode(false);
      chart.xAxisMode = 'delta';
      chart.baseTime = 0;
      smoothSlider.value = "75";
      setSmoothingUI(sliderToTau(75));
      chart.setSeries([], []);
    });

    chart.onSelectRange = (range)=>{
      if (!range) return;
      const x1 = Math.max(range[0], current.cutoffX);
      const x2 = Math.max(x1, range[1]);
      current.selection = [x1, x2];
      zoomClearBtn.disabled = false;
      try { updateSelectedSegmentOnMap(current.selection); } catch (e) {}
      renderChart();
      updateStatsUI();
    };

    // Explain picker behavior to users on mobile
try {
  const hint = document.getElementById('fileHint');
  if (hint) {
    const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isAndroid = /Android/i.test(navigator.userAgent);
    if (isiOS) {
      hint.textContent = 'Tip: On iOS, use “Choose File” to select a .FIT file from Files. Photo Library options won\'t work for .FIT.';
    } else if (isAndroid) {
      hint.textContent = 'Tip: On Android, pick a file manager when prompted (not camera/gallery) to select a .FIT file.';
    }
  }
} catch(e) {}

if (fileInput){
  fileInput.addEventListener('change', async (e)=>{
    try { if (messageEl) messageEl.textContent = 'File selected…'; } catch(_) {}
    const file = e.target.files && e.target.files[0];
    if (!file) { return; }
    
    await handleFitFile(file);
  });
}
// Global fallback in case the element reference fails
try{
  document.addEventListener('change', async (ev)=>{
    const t = ev.target;
    if (t && t.id === 'file' && t.files && t.files[0]){
      try { if (messageEl) messageEl.textContent = 'File selected…'; } catch(_) {}
      await handleFitFile(t.files[0]);
    }
  }, true);
}catch(_){ }

window.handleFitFile = async function(file){
      if (!file) { return; }
      
      try { messageEl.textContent = 'Parsing...'; } catch(e) {}
      
      // Enforce .FIT selection (Android may route via */* and give empty/unknown MIME types)
      const isExtFIT = /\.fit$/i.test((file.name || '').trim());
      const isMimeFIT = /^(application\/(vnd\.ant\.fit|fit|octet-stream))$/i.test((file.type || '').trim());
      
      
      // If neither extension nor MIME looks like FIT, reject it
      if (!isExtFIT && !isMimeFIT) {
        messageEl.innerHTML = '<span class="error">Please select a .FIT file.</span>';
        try{ if (fileInput) fileInput.value = ''; }catch(_){ }
        return;
      }
      
      resetBtn.disabled = false;
      zoomModeBtn.disabled = false;
      messageEl.textContent = 'Parsing...';
      try { clearMapLayers(); current.routePoints = []; } catch(e){}
      statsEl.textContent = '';
      activityTimeEl.textContent = '';
      activityTimeEl.style.display = 'none';
      mapBtn.disabled = true;
      zoomClearBtn.disabled = true;

      try {
        
        const buf = await file.arrayBuffer();
        
        const parser = new FitParser();
        
        const { records, devFieldDescriptions, fileIds, deviceInfos, fileCreators } = parser.parse(buf);
        

        current.records = records;
        current.devDesc = devFieldDescriptions;
        current.fileIds = fileIds;
        current.deviceInfos = deviceInfos;
        current.fileCreators = fileCreators;
        current.manufacturer = (function(){
          const pick = (deviceInfos&&deviceInfos[0]) ? deviceInfos[0] : (fileIds&&fileIds[0]);
          const f = (pick && pick.fields) || {};
          const manuf = (typeof f[2] === 'number') ? f[2] : null;
          // COROS sometimes reports as 294 instead of 167
          if (manuf === 294) return 167;
          return manuf;
        })();

        deviceNameEl.textContent = computeDeviceStringFromCreator(deviceInfos, fileIds, fileCreators);

        if (!records.length) { throw new Error('No record data found'); }

        // Elapsed time
        let firstTs = undefined;
        for (const r of records) {
          if (typeof r.timestamp === 'number' && r.timestamp>0) { firstTs = r.timestamp; break; }
        }
        if (firstTs === undefined) {
          records.forEach((r,i)=>r._elapsed = i);
          messageEl.textContent = 'Warning: No timestamps found. Using sample index as elapsed time.';
        } else {
          records.forEach(r => r._elapsed = (r.timestamp - firstTs));
          messageEl.textContent = 'Parsed. Zoom OFF: slide to inspect; Zoom ON: drag-select.';
        }
        current.baseTime = firstTs || 0;

        if (current.baseTime > 0) {
          const lastElapsed = records.length ? records[records.length - 1]._elapsed : 0;
          const startTime = new Date((current.baseTime + FIT_EPOCH_OFFSET) * 1000);
          const endTime = new Date((current.baseTime + lastElapsed + FIT_EPOCH_OFFSET) * 1000);
          activityTimeEl.textContent = `Activity Date: ${fmtDate(startTime)} | Time: ${fmtTOD(startTime)} - ${fmtTOD(endTime)}`;
          activityTimeEl.style.display = 'block';
        } else {
          activityTimeEl.textContent = '';
          activityTimeEl.style.display = 'none';
        }


        // Extract base fields
        const hrRaw = [];
        const distKmRaw = [];
        const paceRaw = [];
        const speedRaw = [];
        const powerRaw = [];
       const cadRaw = [];
        const elevRaw = [];

        let prevDcm = null;
        let prevT = null;

        const route = [];
        for (const r of records) {
          const t = r._elapsed;
          // For mapping: store time->latlon rows
          const lat = r.fields[0];
          const lon = r.fields[1];
          const toDeg = (semi)=> (typeof semi==='number' && isFinite(semi)) ? (semi * 180 / Math.pow(2,31)) : NaN;
          const latDeg = toDeg(lat), lonDeg = toDeg(lon);
          if (isFinite(latDeg) && isFinite(lonDeg) && Math.abs(latDeg)<=90 && Math.abs(lonDeg)<=180) {
            current.routePoints = current.routePoints || [];
            current.routePoints.push({x:t, lat:latDeg, lon:lonDeg});
            route.push([latDeg, lonDeg]);
          }


          const hr = r.fields[3];
          if (typeof hr === 'number' && hr>0 && hr<255) hrRaw.push({x:t, y:hr});

          const c = r.fields[4];
          const pwr = r.fields[7];
          if (typeof c === 'number' && isFinite(c)) {
            let cadVal = c;
            if (current.manufacturer === 1 || current.manufacturer === 167) cadVal = c * 2; // Garmin & COROS cadence in steps/stride -> spm
            cadRaw.push({x:t, y: cadVal});
          }

          const dRaw = r.fields[5];
          if (typeof dRaw === 'number' && isFinite(dRaw)) {
            const dKm = dRaw / 100000; // cm -> km
            distKmRaw.push({x:t, y:dKm});
          }

          // Pace: prefer field 6 (speed) when reliable; otherwise try field 134; otherwise distance delta
          const rawEnh134 = r.fields[134];
          const rawSpeed = r.fields[6]; // may be scaled
          let pace = NaN;

          const decodeSpeed = (v)=>{
            if (typeof v !== 'number' || !isFinite(v)) return NaN;
            if (v > 25) return v/1000; // scaled by 1000
            return v;
          };
          const fromSpeed = (v)=>{
            const s = decodeSpeed(v);
            return (typeof s==='number' && isFinite(s) && s>0.05) ? (1000/s)/60 : NaN;
          };

          // Use field 6 first if plausible (>0.05 m/s)
          if (rawSpeed !== undefined) pace = fromSpeed(rawSpeed);
          // Else try field 134, but only if plausible
          if (!isFinite(pace) && rawEnh134 !== undefined) {
            const s134 = decodeSpeed(rawEnh134);
            if (isFinite(s134) && s134>0.05) pace = (1000/s134)/60;
          }

          if (!isFinite(pace)) {
            if (typeof dRaw === 'number' && isFinite(dRaw) && prevDcm!=null && prevT!=null) {
              const dd_cm = dRaw - prevDcm;
              const dt = t - prevT;
              if (dt > 0 && dd_cm >= 0) {
                const v = (dd_cm/100) / dt; // m/s
                if (v > 0.05) pace = (1000/v)/60;
              }
            }
          }
          paceRaw.push({x:t, y: isFinite(pace) ? pace : NaN});

          // Speed (km/h) - convert from pace (min/km)
          let speed = NaN;
          if (isFinite(pace) && pace > 0) {
            speed = 60 / pace; // Convert min/km to km/h
          }
          speedRaw.push({x:t, y: speed});

          // Power (W)
          if (typeof pwr === 'number' && isFinite(pwr) && pwr >= 0) {
            powerRaw.push({x:t, y:pwr});
          }

          // Elevation (meters, can be negative) from enhanced_altitude (78) or altitude (2)
          // FIT spec: scale=5, offset=500 => meters = raw/5 - 500
          const rawEnhAlt = r.fields[78];
          const rawAlt = r.fields[2];
          const decodeAlt = (v)=>{
            if (typeof v !== 'number' || !isFinite(v)) return NaN;
            const m = v/5 - 500;
            // discard obviously invalid values
            if (!isFinite(m) || m < -1000 || m > 9000) return NaN;
            return m;
          };
          let elevVal = NaN;
          if (rawEnhAlt !== undefined) elevVal = decodeAlt(rawEnhAlt);
          if (!Number.isFinite(elevVal) && rawAlt !== undefined) elevVal = decodeAlt(rawAlt);
          if (Number.isFinite(elevVal)) {
            elevRaw.push({x:t, y: elevVal});
          }

          // Route (lat/lon in semicircles -> degrees)
          // (handled above while building current.routePoints and route)


          if (typeof dRaw === 'number' && isFinite(dRaw)) { prevDcm = dRaw; prevT = t; }
        }
        current.hrRaw = hrRaw;
        current.distRaw = distKmRaw;
        current.paceRaw = paceRaw;
        current.speedRaw = speedRaw;
        current.powerRaw = powerRaw;
        current.cadRaw = cadRaw;

        // Developer fields: Core/Skin temps
        const allDevKeys = new Set();
        for (const rec of records) for (const k in rec.dev) allDevKeys.add(k);
        const candidates = Array.from(allDevKeys);

        let coreKey = null, skinKey = null;

        // COROS specific: look for temperature developer fields with various naming patterns
        if (current.manufacturer === 167) {
          let coreDevKey = null, skinDevKey = null;
          
          // Search for temperature fields in developer data
          for (const [k, desc] of devFieldDescriptions.entries()) {
            const name = (desc.name || '').toLowerCase().trim();
            
            // Core temperature patterns: 'core temperature', 'core_temperature', 'XX_core_temperature'
            if ((name.includes('core') && name.includes('temperature')) || 
                name.includes('core_temperature') || 
                /^\d{2}_core_temperature$/.test(name)) {
              coreDevKey = k;
            }
            
            // Skin temperature patterns: 'skin temperature', 'skin_temperature', 'XX_skin_temperature'  
            if ((name.includes('skin') && name.includes('temperature')) || 
                name.includes('skin_temperature') || 
                /^\d{2}_skin_temperature$/.test(name)) {
              skinDevKey = k;
            }
          }
          
          const coreRawCoros = [];
          const skinRawCoros = [];
          
          // Extract temperature data if fields found
          if (coreDevKey) {
            const desc = devFieldDescriptions.get(coreDevKey) || {};
            const scale = (Number.isFinite(desc.scale) && desc.scale !== 0) ? desc.scale : 0.01; // default /100
            const offset = Number.isFinite(desc.offset) ? desc.offset : 0;
            // Stash for scaledSeries later so COROS uses proper scaling
            current.coreScale = scale;
            current.coreOffset = offset;
            
            for (const r of records) {
              const v = r.dev[coreDevKey];
              if (typeof v === 'number' && isFinite(v) && v !== 0) {
                coreRawCoros.push({x: r._elapsed, y: v * scale + offset});
              }
            }
          }
          
          if (skinDevKey) {
            const desc = devFieldDescriptions.get(skinDevKey) || {};
            const scale = (Number.isFinite(desc.scale) && desc.scale !== 0) ? desc.scale : 0.05; // default /20
            const offset = Number.isFinite(desc.offset) ? desc.offset : 0;
            // Stash for scaledSeries later so COROS uses proper scaling
            current.skinScale = scale;
            current.skinOffset = offset;
            
            for (const r of records) {
              const v = r.dev[skinDevKey];
              if (typeof v === 'number' && isFinite(v) && v !== 0) {
                skinRawCoros.push({x: r._elapsed, y: v * scale + offset});
              }
            }
          }
          
          // Only use COROS temperature data if we found actual temperature fields
          if (coreRawCoros.length >= 2 || skinRawCoros.length >= 2) {
            current.coreRaw = coreRawCoros;
            current.skinRaw = skinRawCoros;
            coreKey = coreDevKey || null;
            skinKey = skinDevKey || null;
          }
          // Note: If no temperature fields found, the app will fall back to generic developer field detection
        }
        function descFor(k){ return devFieldDescriptions.get(k) || {}; }
        function looksLikeCore(d){ return d && d.name && /core/i.test(d.name); }
        function looksLikeSkin(d){ return d && d.name && /skin/i.test(d.name); }
        function unitsC(d){ return d && d.units && /c|°/i.test(d.units); }
        if (current.manufacturer !== 167) {
          for (const k of candidates) {
            const d = descFor(k);
            if (unitsC(d) && looksLikeCore(d)) coreKey = coreKey || k;
            if (unitsC(d) && looksLikeSkin(d)) skinKey = skinKey || k;
          }
        }

        function seriesFromKey(key){
          if (!key) return [];
          const arr=[];
          const desc = devFieldDescriptions.get(key) || {};
          const scaleFromDesc = (Number.isFinite(desc.scale) && desc.scale!==0) ? desc.scale : 1;
          const offsetFromDesc = Number.isFinite(desc.offset) ? desc.offset : 0;
          for (const rec of records) {
            const v = rec.dev[key];
            if (typeof v === 'number' && isFinite(v)) {
              const y = v * scaleFromDesc + offsetFromDesc;
              arr.push({x:rec._elapsed, y});
            }
          }
          return arr;
        }

        const devSeriesByKey = new Map();
        for (const k of candidates) devSeriesByKey.set(k, seriesFromKey(k));

        function guessTempKey(excludeKey=null){
          let bestKey=null, bestScore=-Infinity, bestScale=1, bestOffset=0;
          for (const k of candidates) {
            if (k===excludeKey) continue;
            const arr = devSeriesByKey.get(k);
            if (!arr || arr.length<5) continue;
            const ys = arr.map(p=>p.y).filter(Number.isFinite).slice().sort((a,b)=>a-b);
            const mid = ys[Math.floor(ys.length/2)];
            let score = -Math.abs(mid-37); let scale=1; let offset=0;
            const d = descFor(k);
            if (Number.isFinite(d.scale) && d.scale !== 0) scale = d.scale;
            if (Number.isFinite(d.offset)) offset = d.offset;
            if (unitsC(d)) score += 2;
            if (looksLikeCore(d) || looksLikeSkin(d)) score += 1;
            if (score > bestScore) {bestScore=score; bestKey=k; bestScale=scale; bestOffset=offset;}
          }
          return {key:bestKey, scale:bestScale, offset:bestOffset};
        }
        if (current.manufacturer !== 167) {
          if (!coreKey) { const g = guessTempKey(null); coreKey = g.key; current.coreScale = g.scale || 1; current.coreOffset = g.offset || 0; }
        if (!skinKey) { const g = guessTempKey(coreKey); skinKey = g.key; current.skinScale = g.scale || 1; current.skinOffset = g.offset || 0; }
        }

        function scaledSeries(key, scale=1, offset=0){
          if (!key) return [];
          const arr = [];
          for (const rec of records) {
            const v = rec.dev[key];
            if (typeof v === 'number' && isFinite(v)) {
              const y = v*scale + offset;
              if (y > -1000 && y < 1000) arr.push({x:rec._elapsed, y});
            }
          }
          return arr;
        }
        let coreRaw = scaledSeries(coreKey, current.coreScale, current.coreOffset||0);
        let skinRaw = scaledSeries(skinKey, current.skinScale, current.skinOffset||0);

        function adjustIfNeeded(series){
          if (!series.length) return {series, scale:1};
          const ys = series.map(p=>p.y).sort((a,b)=>a-b);
          const mid = ys[Math.floor(ys.length/2)];
          if (mid > 60) return {series: series.map(p=>({x:p.x,y:p.y/100})), scale:0.01};
          if (mid < 5 && mid > 0.05) return {series: series.map(p=>({x:p.x,y:p.y*10})), scale:10};
          return {series, scale:1};
        }
        if (current.manufacturer !== 167) {
          if (!coreRaw.length && coreKey) { const alt = adjustIfNeeded(seriesFromKey(coreKey)); coreRaw = alt.series; current.coreScale *= alt.scale; /* offset remains user-controlled */ }
          if (!skinRaw.length && skinKey) { const alt = adjustIfNeeded(seriesFromKey(skinKey)); skinRaw = alt.series; current.skinScale *= alt.scale; /* offset remains user-controlled */ }
        }

        current.coreKey = coreKey || null;
        current.skinKey = skinKey || null;
        current.coreRaw = coreRaw;
        current.skinRaw = skinRaw;

        // HSI detection: "heat strain index"
        const hsiKey = detectHSIKey(devFieldDescriptions);
        current.hsiRaw = [];
        if (hsiKey) {
          for (const rec of records) {
            const v = rec.dev[hsiKey];
            if (typeof v === 'number' && isFinite(v)) current.hsiRaw.push({x:rec._elapsed, y:clamp(v, 0, 5)});
          }
        }

        // If no base enhanced_altitude, try dev field by name
        if (!elevRaw.length) {
          const elevKey = detectEnhancedAltitudeDevKey(devFieldDescriptions);
          if (elevKey) {
            for (const rec of records) {
              const v = rec.dev[elevKey];
              if (typeof v === 'number' && isFinite(v)) elevRaw.push({x:rec._elapsed, y:v});
            }
          }
        }
        current.elevRaw = elevRaw;

        // Update route map if we have points (no gradient by default)
        try { updateRouteOnMap(route); } catch (e) { /* ignore */ }

        const tau = sliderToTau(smoothSlider.value);
        setSmoothingUI(tau);
        recalcSmoothing();

        updateCutoff();

        current.selection = null;
        zoomClearBtn.disabled = true;
        renderChart();
        updateStatsUI();

        // Compute presence flags and update UI chips
        const hasHR   = Array.isArray(current.hrRaw)   && current.hrRaw.some(p => Number.isFinite(p.y));
        const hasCore = Array.isArray(current.coreRaw) && current.coreRaw.some(p => Number.isFinite(p.y));
        const hasSkin = Array.isArray(current.skinRaw) && current.skinRaw.some(p => Number.isFinite(p.y));
        const hasHSI  = Array.isArray(current.hsiRaw)  && current.hsiRaw.some(p => Number.isFinite(p.y));
        const hasDist = Array.isArray(current.distRaw) && current.distRaw.some(p => Number.isFinite(p.y));
        const hasPace = Array.isArray(current.paceRaw) && current.paceRaw.some(p => Number.isFinite(p.y));
        const hasSpeed= Array.isArray(current.speedRaw)&& current.speedRaw.some(p => Number.isFinite(p.y));
        const hasPower= Array.isArray(current.powerRaw)&& current.powerRaw.some(p => Number.isFinite(p.y));
        const hasCad  = Array.isArray(current.cadRaw)  && current.cadRaw.some(p => Number.isFinite(p.y));

        showIf(document.getElementById('chip-hr'), hasHR);
        showIf(document.getElementById('chip-core'), hasCore);
        showIf(document.getElementById('chip-skin'), hasSkin);
        showIf(document.getElementById('chip-hsi'), hasHSI);
        showIf(document.getElementById('chip-dist'), hasDist);
        showIf(document.getElementById('chip-pace'), hasPace);
        showIf(document.getElementById('chip-speed'), hasSpeed);
        showIf(document.getElementById('chip-power'), hasPower);
        showIf(document.getElementById('chip-cad'), hasCad);

        const missing = [];
        if (!hasHR)   missing.push('Heart Rate');
        if (!hasCore) missing.push('Core Temp');
        if (!hasSkin) missing.push('Skin Temp');
        if (!hasHSI)  missing.push('Heat Strain Index');
        if (!hasDist) missing.push('Distance');
        if (!hasPace) missing.push('Pace');
        if (!hasSpeed)missing.push('Speed');
        if (!hasPower)missing.push('Power');
        if (!hasCad)  missing.push('Cadence');
        setMissingMsg(missing);

        const parts = [];
        messageEl.textContent = 'Zoom OFF: slide to inspect; Zoom ON: drag-select.';
        messageEl.textContent = parts.join(' ');

        mapBtn.disabled = (candidates.length === 0);
      } catch (err) {
        console.error(err);
        logDbg('ERROR: ' + (err && err.stack ? err.stack : (err && err.message ? err.message : String(err))));
        messageEl.innerHTML = '<span class="error">Error: ' + (err && err.message ? err.message : String(err)) + '</span>';
      }
    };

    function detectHSIKey(devDesc){
      for (const [k, d] of devDesc.entries()) {
        const name = (d.name||'').toLowerCase().trim();
        if (!name) continue;
        if (name === 'heat strain index') return k;
        if ((name.includes('heat') && name.includes('strain')) || name.includes('hsi')) return k;
      }
      return null;
    }

    function detectEnhancedAltitudeDevKey(devDesc){
      for (const [k, d] of devDesc.entries()) {
        const nm = (d.name||'').toLowerCase().trim();
        if (!nm) continue;
        if (nm === 'enhanced altitude') return k;
        if (nm.includes('enhanced') && nm.includes('altitude')) return k;
      }
      return null;
    }

    function smoothZeroPhase(points, tauSec){
      if (!points || points.length === 0 || !isFinite(tauSec) || tauSec <= 0) return (points||[]).slice();

      let i0 = 0;
      while (i0 < points.length && !Number.isFinite(points[i0].y)) i0++;
      if (i0 >= points.length) return points.map(p=>({x:p.x, y:NaN}));

      const f = new Array(points.length);
      let y = points[i0].y;
      for (let i=0;i<=i0;i++) f[i] = {x:points[i].x, y};
      for (let i=i0+1; i<points.length; i++){
        const dt = Math.max(0, points[i].x - points[i-1].x);
        const alpha = 1 - Math.exp(-dt / tauSec);
        const v = Number.isFinite(points[i].y) ? points[i].y : y;
        y = y + alpha * (v - y);
        f[i] = {x: points[i].x, y};
      }

      const b = new Array(points.length);
      let yb = f[points.length-1].y;
      b[points.length-1] = {x: f[points.length-1].x, y: yb};
      for (let i=points.length-2; i>=0; i--){
        const dt = Math.max(0, f[i+1].x - f[i].x);
        const alpha = 1 - Math.exp(-dt / tauSec);
        const v = Number.isFinite(f[i].y) ? f[i].y : yb;
        yb = yb + alpha * (v - yb);
        b[i] = {x: f[i].x, y: yb};
      }
      return b;
    }

    function recalcSmoothing(){
      const tau = current.tauSec || 0;
      current.hrSeries   = smoothZeroPhase(current.hrRaw,   tau);
      current.coreSeries = smoothZeroPhase(current.coreRaw, tau);
      current.skinSeries = smoothZeroPhase(current.skinRaw, tau);
      current.hsiSeries  = smoothZeroPhase(current.hsiRaw,  tau);
      current.distSeries = smoothZeroPhase(current.distRaw, tau);
      current.paceSeries = smoothZeroPhase(current.paceRaw, tau);
      current.speedSeries = smoothZeroPhase(current.speedRaw, tau);
      current.powerSeries = smoothZeroPhase(current.powerRaw, tau);
      current.cadSeries  = smoothZeroPhase(current.cadRaw,  tau);
      current.elevSeries = smoothZeroPhase(current.elevRaw, tau);
    }

    function updateCutoff(){
      let cut = 0;
      const eps = 1e-9;
      if (current.coreRaw && current.coreRaw.length) {
        for (const p of current.coreRaw) {
          if (Number.isFinite(p.y) && p.y > 0 + eps) { cut = p.x; break; }
        }
      }
      current.cutoffX = cut;
    }

    function inView(x){
      if (toggles.trim && toggles.trim.checked) {
        if (x < current.cutoffX) return false;
      }
      if (current.selection) {
        if (x < current.selection[0] || x > current.selection[1]) return false;
      }
      return true;
    }
    function filterPoints(arr){ return (arr||[]).filter(p => inView(p.x)); }

    function renderChart(){
      chart.xAxisMode = current.xAxisMode;
      chart.baseTime = current.baseTime;

      const series = [
        { id:'core', name:'Core Temp',  color:getVar('--core','#1e88e5'), axis:'left',  visible: toggles.core.checked, points: filterPoints(current.coreSeries), fmt:(v)=> `${(Math.round(v*100)/100).toFixed(2)} °C` },
        { id:'skin', name:'Skin Temp',  color:getVar('--skin','#fb8c00'), axis:'left',  visible: toggles.skin.checked, points: filterPoints(current.skinSeries), fmt:(v)=> `${(Math.round(v*100)/100).toFixed(2)} °C` },

        { id:'hr',   name:'Heart Rate', color:getVar('--hr','#e53935'),   axis:'right', visible: toggles.hr.checked,   points: filterPoints(current.hrSeries),   fmt:(v)=> `${Math.round(v)} bpm` },
        { id:'hsi',  name:'HSI',        color:getVar('--hsi','#ab47bc'),  axis:'right', visible: toggles.hsi.checked,  points: filterPoints(current.hsiSeries),  fmt:(v)=> Number.isFinite(v)? (Math.round(v*100)/100).toFixed(2):'--' },
        { id:'dist', name:'Distance',   color:getVar('--dist','#66bb6a'), axis:'right', visible: toggles.dist.checked, points: filterPoints(current.distSeries), fmt:(v)=> Number.isFinite(v)? (Math.round(v*100)/100).toFixed(2)+' km':'--' },
        { id:'pace', name:'Pace',       color:getVar('--pace','#26c6da'), axis:'right', visible: toggles.pace.checked, points: filterPoints(current.paceSeries), fmt:(v)=> fmtPace(v) },
        { id:'speed', name:'Speed',     color:getVar('--speed','#ff7043'), axis:'right', visible: toggles.speed.checked, points: filterPoints(current.speedSeries), fmt:(v)=> Number.isFinite(v)? (Math.round(v*100)/100).toFixed(2)+' km/h':'--' },
        { id:'power', name:'Power',     color:getVar('--power','#9c27b0'), axis:'right', visible: toggles.power.checked, points: filterPoints(current.powerSeries), fmt:(v)=> Number.isFinite(v)? Math.round(v)+' W':'--' },
        { id:'cad',  name:'Cadence',    color:getVar('--cad','#ffd54f'),  axis:'right', visible: toggles.cad.checked,  points: filterPoints(current.cadSeries),  fmt:(v)=> Number.isFinite(v)? Math.round(v)+' spm':'--' },
      ];
      const elev = filterPoints(current.elevSeries);
      chart.setSeries(series, elev);
    }

    function averageInView(arr){
      if (!arr || !arr.length) return null;
      let sum=0, n=0;
      for (const p of arr){ if (inView(p.x) && Number.isFinite(p.y)) { sum+=p.y; n++; } }
      return n>0 ? (sum/n) : null;
    }
    function arrayMaxInView(arr){
      if (!arr || !arr.length) return null;
      let m = -Infinity;
      for (const p of arr) {
        if (!inView(p.x)) continue;
        if (Number.isFinite(p.y)) m = Math.max(m, p.y);
      }
      return (m===-Infinity) ? null : m;
    }

    function arrayMinInView(arr){
      if (!arr || !arr.length) return null;
      let m = Infinity;
      for (const p of arr) {
        if (!inView(p.x)) continue;
        if (Number.isFinite(p.y)) m = Math.min(m, p.y);
      }
      return (m===Infinity) ? null : m;
    }

    function updateStatsUI(){
      const hrMax   = arrayMaxInView(current.hrRaw);
      const coreMax = arrayMaxInView(current.coreRaw);
      const skinMax = arrayMaxInView(current.skinRaw);

      const parts = [
        `<span>Max Core: <span class="kbd">${coreMax!=null ? (Math.round(coreMax*100)/100).toFixed(2)+' °C' : '--'}</span></span>`,
        `<span>Max Skin: <span class="kbd">${skinMax!=null ? (Math.round(skinMax*100)/100).toFixed(2)+' °C' : '--'}</span></span>`,
        `<span>Max HR: <span class="kbd">${hrMax!=null ? Math.round(hrMax)+' bpm' : '--'}</span></span>`,
        `<span>Window: <span class="kbd">${fmtHMS(viewDuration())}</span></span>`
      ];

      if (toggles.hsi.checked) {
        const h = arrayMaxInView(current.hsiRaw);
        parts.push(`<span>Max HSI: <span class="kbd">${h!=null ? (Math.round(h*100)/100).toFixed(2) : '--'}</span></span>`);
      }
      if (toggles.dist.checked) {
        const d = arrayMaxInView(current.distRaw);
        parts.push(`<span>Max Distance: <span class="kbd">${d!=null ? (Math.round(d*100)/100).toFixed(2)+' km' : '--'}</span></span>`);
      }
      if (toggles.pace.checked) {
        const pBest = arrayMinInView(current.paceRaw);
        const pAvg = averageInView(current.paceRaw);
        parts.push(`<span>Best Pace: <span class="kbd">${pBest!=null ? fmtPace(pBest) : '--'}</span></span>`);
        parts.push(`<span>Avg Pace: <span class="kbd">${pAvg!=null ? fmtPace(pAvg) : '--'}</span></span>`);
      }
      if (toggles.hr.checked) {
        const hrAvg = averageInView(current.hrRaw);
        parts.push(`<span>Avg HR: <span class="kbd">${hrAvg!=null ? Math.round(hrAvg)+' bpm' : '--'}</span></span>`);
      }
      if (toggles.speed.checked) {
        const s = arrayMaxInView(current.speedRaw);
        parts.push(`<span>Max Speed: <span class="kbd">${s!=null ? (Math.round(s*100)/100).toFixed(2)+' km/h' : '--'}</span></span>`);
      }
      if (toggles.cad.checked) {
        const c = arrayMaxInView(current.cadRaw);
        parts.push(`<span>Max Cadence: <span class="kbd">${c!=null ? Math.round(c)+' spm' : '--'}</span></span>`);
      }

      statsEl.innerHTML = parts.join(' ');
    }

    function viewDuration(){
      let start = (toggles.trim && toggles.trim.checked) ? current.cutoffX : 0;
      let end = (current.records.length ? current.records[current.records.length-1]._elapsed : 0);
      if (current.selection) {
        start = Math.max(start, current.selection[0]);
        end = Math.min(end, current.selection[1]);
      }
      return Math.max(0, end - start);
    }

    function updateActivityTimeForTrim() {
      if (current.baseTime > 0 && toggles.trim && toggles.trim.checked && current.cutoffX > 0) {
        const lastElapsed = current.records.length ? current.records[current.records.length - 1]._elapsed : 0;
        const originalStartTime = new Date((current.baseTime + FIT_EPOCH_OFFSET) * 1000);
        const trimmedStartTime = new Date((current.baseTime + current.cutoffX + FIT_EPOCH_OFFSET) * 1000);
        const endTime = new Date((current.baseTime + lastElapsed + FIT_EPOCH_OFFSET) * 1000);
        activityTimeEl.textContent = `Activity Date: ${fmtDate(originalStartTime)} | Time: ${fmtTOD(trimmedStartTime)} - ${fmtTOD(endTime)} (trimmed from ${fmtTOD(originalStartTime)})`;
        activityTimeEl.style.display = 'block';
      } else if (current.baseTime > 0) {
        const lastElapsed = current.records.length ? current.records[current.records.length - 1]._elapsed : 0;
        const startTime = new Date((current.baseTime + FIT_EPOCH_OFFSET) * 1000);
        const endTime = new Date((current.baseTime + lastElapsed + FIT_EPOCH_OFFSET) * 1000);
        activityTimeEl.textContent = `Activity Date: ${fmtDate(startTime)} | Time: ${fmtTOD(startTime)} - ${fmtTOD(endTime)}`;
        activityTimeEl.style.display = 'block';
      } else {
        activityTimeEl.textContent = '';
        activityTimeEl.style.display = 'none';
      }
    }

    const modalBackdrop = document.getElementById('modalBackdrop');
    const modalEl = document.querySelector('.modal');
    const coreSelect = document.getElementById('coreSelect');
    const skinSelect = document.getElementById('skinSelect');
    const coreScaleInput = document.getElementById('coreScale');
    const skinScaleInput = document.getElementById('skinScale');
    const coreOffsetInput = document.getElementById('coreOffset');
    const skinOffsetInput = document.getElementById('skinOffset');
    const cancelMap = document.getElementById('cancelMap');
    const applyMap = document.getElementById('applyMap');
    const mapHint = document.getElementById('mapHint');

    let lastFocusEl = null;

    mapBtn.addEventListener('click', ()=>{
      const devKeys = getAllDeveloperKeys(current.records);
      if (devKeys.length === 0) {
        messageEl.textContent = 'No developer fields found in this file.';
        return;
      }
      coreSelect.innerHTML = '';
      skinSelect.innerHTML = '';
      const opts = devKeys.map(k => {
        const desc = current.devDesc.get(k) || {};
        const label = niceDevLabel(k, desc, current.records);
        return {k, label};
      });
      for (const {k,label} of opts) {
        const o1 = document.createElement('option'); o1.value = k; o1.textContent = label; coreSelect.appendChild(o1);
        const o2 = document.createElement('option'); o2.value = k; o2.textContent = label; skinSelect.appendChild(o2);
      }
      if (current.coreKey) coreSelect.value = current.coreKey;
      if (current.skinKey) skinSelect.value = current.skinKey;
      coreScaleInput.value = String(current.coreScale || 1);
      skinScaleInput.value = String(current.skinScale || 1);
      coreOffsetInput.value = String(current.coreOffset || 0);
      skinOffsetInput.value = String(current.skinOffset || 0);
      mapHint.innerHTML = sampleHintHTML(current.records, devKeys);

      lastFocusEl = document.activeElement;
      modalBackdrop.style.display = 'flex';
      setTimeout(()=>{ modalEl.focus(); }, 0);
    });

    function closeModal(){
      modalBackdrop.style.display='none';
      if (lastFocusEl && typeof lastFocusEl.focus === 'function') lastFocusEl.focus();
    }

    cancelMap.addEventListener('click', closeModal);

    applyMap.addEventListener('click', ()=>{
      const coreKey = coreSelect.value || null;
      const skinKey = skinSelect.value || null;
      let coreScale = parseFloat(coreScaleInput.value); if (!Number.isFinite(coreScale) || coreScale===0) coreScale = 1;
      let skinScale = parseFloat(skinScaleInput.value); if (!Number.isFinite(skinScale) || skinScale===0) skinScale = 1;
      let coreOffset = parseFloat(coreOffsetInput.value); if (!Number.isFinite(coreOffset)) coreOffset = 0;
      let skinOffset = parseFloat(skinOffsetInput.value); if (!Number.isFinite(skinOffset)) skinOffset = 0;

      current.coreKey = coreKey; current.skinKey = skinKey;
      current.coreScale = coreScale; current.skinScale = skinScale;
      current.coreOffset = coreOffset; current.skinOffset = skinOffset;

      const coreRaw = [];
      const skinRaw = [];
      for (const r of current.records) {
        if (coreKey && typeof r.dev[coreKey] === 'number' && isFinite(r.dev[coreKey])) {
          coreRaw.push({x:r._elapsed, y:r.dev[coreKey]*coreScale + coreOffset});
        }
        if (skinKey && typeof r.dev[skinKey] === 'number' && isFinite(r.dev[skinKey])) {
          skinRaw.push({x:r._elapsed, y:r.dev[skinKey]*skinScale + skinOffset});
        }
      }
      current.coreRaw = coreRaw;
      current.skinRaw = skinRaw;

      recalcSmoothing();
      updateCutoff();
      updateActivityTimeForTrim();
      renderChart();
      updateStatsUI();

      const parts = [];
      parts.push('Updated mapping.');
      if (!coreRaw.length) parts.push('No core temp points with this mapping.');
      if (!skinRaw.length) parts.push('No skin temp points with this mapping.');
      messageEl.textContent = parts.join(' ');

      closeModal();
    });

    modalBackdrop.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape') { e.preventDefault(); closeModal(); }
      if (e.key === 'Tab') {
        // simple focus trap: keep focus within modal
        const focusables = modalBackdrop.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        const list = Array.from(focusables).filter(el=> el.offsetParent !== null);
        if (list.length === 0) return;
        const first = list[0], last = list[list.length-1];
        if (e.shiftKey) {
          if (document.activeElement === first) { e.preventDefault(); last.focus(); }
        } else {
          if (document.activeElement === last) { e.preventDefault(); first.focus(); }
        }
      }
    });

    function getAllDeveloperKeys(records){
      const set = new Set();
      for (const r of records) for (const k in r.dev) set.add(k);
      return Array.from(set);
    }

    function niceDevLabel(key, desc, records){
      const sample = (() => { for (const r of records) if (typeof r.dev[key] === 'number' && isFinite(r.dev[key])) return r.dev[key]; return null; })();
      const name = desc?.name ? desc.name : 'Field ' + key;
      const units = desc?.units ? ' ' + desc.units : '';
      const val = (sample!=null) ? ` [ex: ${Math.round(sample*100)/100}]` : '';
      return name + (units ? ` (${units.trim()})` : '') + ' -- ' + key + val;
    }

    function sampleHintHTML(records, devKeys){
      let html = 'First sample values per field: ';
      const parts = [];
      for (const k of devKeys) {
        let v=null;
        for (const r of records) if (typeof r.dev[k]==='number') { v=r.dev[k]; break; }
        if (v!=null) parts.push(`<span class="kbd">${k}</span>: ${Math.round(v*100)/100}`);
      }
      html += parts.join(', ');
      return html;
    }

    function computeDeviceStringFromCreator(deviceInfos, fileIds, fileCreators){
      let picked = null;
      for (const d of deviceInfos||[]) {
        const f = d.fields||{};
        if (f[0]===0) { picked = d; break; }
      }
      if (!picked && deviceInfos && deviceInfos.length) picked = deviceInfos[0];

      let manuf = null, product = null, serial = null, sw = null, productName = null; let productStr = null;
      if (picked) {
        const f = picked.fields||{};
        manuf = f[2];
        product = f[4];
        serial = f[3];
        sw = f[5];
        if (typeof f[27] === 'string' && f[27].trim()) productName = f[27].trim(); // product_name
      }
      if ((manuf==null || product==null || serial==null) && fileIds && fileIds.length) {
        const f = fileIds[0].fields||{};
        if (manuf==null) manuf = f[1];
        if (product==null) product = f[2];
        if (serial==null) serial = f[3];
      }
      if (sw==null && fileCreators && fileCreators.length) {
        const fc = fileCreators[0].fields||{};
        if (typeof fc[0] === 'number') {
          sw = fc[0];
        }
      }
      // Normalize sw to xx.yy by dividing by 100 when numeric
      if (typeof sw === 'number') sw = sw/100;

      let brandStr = (typeof manuf === 'number' && MANUFACTURERS[manuf]) ? MANUFACTURERS[manuf] : (manuf!=null ? String(manuf) : 'Unknown');
      // For COROS, avoid showing numeric code like '294' before the model string
      if (brandStr === 'Unknown' && manuf === 294) brandStr = 'COROS';

      // Prefer product_name string if available (e.g., 'fr55'), with normalization
      let prodStr = productName || null;
      if (!prodStr) {
        // Fallback to numeric code (product ID)
        if (brandStr === 'Garmin' && product!=null) {
          const garminMap = {
            // Common Forerunners (subset; extend as needed)
            2691: 'Forerunner 45', 2693: 'Forerunner 45S',
            3869: 'Forerunner 55',
            2713: 'Forerunner 245', 2729: 'Forerunner 245 Music',
            3315: 'Forerunner 255', 3321: 'Forerunner 255S', 3329: 'Forerunner 255 Music',
            2711: 'Forerunner 645', 2712: 'Forerunner 645 Music',
            3510: 'Forerunner 745',
            2710: 'Forerunner 935',
            3284: 'Forerunner 945', 3512: 'Forerunner 945 LTE',
            4000: 'Forerunner 955', 4015: 'Forerunner 965',
            // Fenix (partial examples)
            3192: 'Fenix 6', 3195: 'Fenix 6 Pro', 3358: 'Fenix 7', 3891: 'Fenix 7 Pro',
            // Edge (partial examples)
            1030: 'Edge 1030', 2962: 'Edge 530', 3003: 'Edge 830',
            // Venu/Vivoactive (partial examples)
            3785: 'Venu 2', 3812: 'Venu 2S', 3482: 'Vivoactive 4',
          };
          prodStr = garminMap[product] || String(product);
        } else {
          prodStr = (product!=null ? String(product) : 'Unknown');
        }
      }
      prodStr = normalizeProductName(brandStr, prodStr);

      // Build optional details only if present
      const details = [];
      if (sw!=null) {
        let swStr = String(sw);
        if (typeof sw === 'number' && sw % 1 !== 0) swStr = (Math.round(sw*100)/100).toFixed(2);
        details.push(`sw version = ${swStr}`);
      }
      if (serial!=null) {
        details.push(`serial = ${String(serial)}`);
      }
      const detailsStr = details.length ? ` (${details.join(', ')})` : '';
      return `${brandStr} ${prodStr}${detailsStr}`;
    }

    setSmoothingUI(sliderToTau(smoothSlider.value));
    chart.setZoomMode(false);

    // Show Map Fields button only for local development (localhost or file://)
    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.protocol === 'file:') {
      mapBtn.style.display = 'inline-block';
      // Append Map Fields guidance when available
      const footer = document.getElementById('footerText');
      if (footer) {
        footer.innerHTML += ' If temperatures don’t appear automatically, use “Map Fields” to assign developer data fields to Core/Skin and optionally apply a scale (e.g., 0.01).';
      }
    }
  </script>
</body>
</html>
